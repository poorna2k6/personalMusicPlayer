commit 893da4e5e21e834264434b0d98f6fe52d020b3a6
Author: ppakala <ppakala@matildacloud.com>
Date:   Wed Feb 18 22:12:16 2026 -0600

    antiGravity Fix

diff --git a/docs/app.js b/docs/app.js
index f6deaa4..85fc1c4 100644
--- a/docs/app.js
+++ b/docs/app.js
@@ -13,7 +13,7 @@ function safeParse(key, fallback) {
     return JSON.parse(raw);
   } catch (e) {
     console.warn(`[safeParse] Corrupted localStorage key "${key}" â€” cleared.`, e);
-    try { localStorage.removeItem(key); } catch (_) {}
+    try { localStorage.removeItem(key); } catch (_) { }
     return fallback;
   }
 }
@@ -164,15 +164,15 @@ const analytics = {
     else if (ua.includes('Firefox')) { browser = 'Firefox'; browserVersion = ua.match(/Firefox\/(\d+)/)?.[1] || ''; }
 
     // OS detection
-    if (ua.includes('iPhone')) { os = 'iOS'; osVersion = ua.match(/OS (\d+[_\.]\d+)/)?.[1]?.replace('_','.') || ''; deviceType = 'Mobile'; deviceModel = 'iPhone'; }
-    else if (ua.includes('iPad')) { os = 'iPadOS'; osVersion = ua.match(/OS (\d+[_\.]\d+)/)?.[1]?.replace('_','.') || ''; deviceType = 'Tablet'; deviceModel = 'iPad'; }
+    if (ua.includes('iPhone')) { os = 'iOS'; osVersion = ua.match(/OS (\d+[_\.]\d+)/)?.[1]?.replace('_', '.') || ''; deviceType = 'Mobile'; deviceModel = 'iPhone'; }
+    else if (ua.includes('iPad')) { os = 'iPadOS'; osVersion = ua.match(/OS (\d+[_\.]\d+)/)?.[1]?.replace('_', '.') || ''; deviceType = 'Tablet'; deviceModel = 'iPad'; }
     else if (ua.includes('Android')) {
       os = 'Android'; osVersion = ua.match(/Android (\d+[\.]\d*)/)?.[1] || '';
       deviceType = ua.includes('Mobile') ? 'Mobile' : 'Tablet';
       deviceModel = ua.match(/;\s*([^;)]+)\s*Build/)?.[1]?.trim() || ua.match(/;\s*([^;)]+)\s*\)/)?.[1]?.trim() || 'Android Device';
     }
     else if (ua.includes('Windows')) { os = 'Windows'; osVersion = ua.match(/Windows NT (\d+\.\d+)/)?.[1] || ''; }
-    else if (ua.includes('Mac OS X')) { os = 'macOS'; osVersion = ua.match(/Mac OS X (\d+[_\.]\d+)/)?.[1]?.replace(/_/g,'.') || ''; }
+    else if (ua.includes('Mac OS X')) { os = 'macOS'; osVersion = ua.match(/Mac OS X (\d+[_\.]\d+)/)?.[1]?.replace(/_/g, '.') || ''; }
     else if (ua.includes('Linux')) { os = 'Linux'; }
     else if (ua.includes('CrOS')) { os = 'ChromeOS'; deviceType = 'Desktop'; }
 
@@ -320,7 +320,7 @@ const analytics = {
           this.events.push(...pendingEvents);
           localStorage.removeItem('pending_analytics');
         }
-      } catch (_) {}
+      } catch (_) { }
     }
   },
 
@@ -433,7 +433,7 @@ const analytics = {
       const existing = JSON.parse(localStorage.getItem('pending_analytics') || '[]');
       const merged = existing.concat(events).slice(-200); // keep last 200
       localStorage.setItem('pending_analytics', JSON.stringify(merged));
-    } catch(_) {}
+    } catch (_) { }
   }
 };
 
@@ -463,7 +463,7 @@ const apiHealth = {
       };
       // If stored state was open but enough time passed, set to half-open
       if (this.mirrors[url].state === 'open' &&
-          Date.now() - this.mirrors[url].lastFail > this.resetTimeout) {
+        Date.now() - this.mirrors[url].lastFail > this.resetTimeout) {
         this.mirrors[url].state = 'half-open';
       }
     });
@@ -975,9 +975,9 @@ function calculateSimilarityScore(track1, track2, currentLanguage, currentGenre)
 
   // P1: Skip signal penalty â€” down-rank skipped artists/genres
   const skipArtist = state.skipSignals[`artist:${getArtistName(track2)}`] || 0;
-  const skipGenre  = state.skipSignals[`genre:${detectGenre(track2)}`] || 0;
+  const skipGenre = state.skipSignals[`genre:${detectGenre(track2)}`] || 0;
   score -= skipArtist * 15;
-  score -= skipGenre  * 8;
+  score -= skipGenre * 8;
 
   return score;
 }
@@ -988,7 +988,7 @@ function recordSkipSignal(track) {
   const listenMs = Date.now() - state.playStartTime;
   if (listenMs > 30000) return; // listened 30s+ = not a skip
   const artistKey = `artist:${getArtistName(track)}`;
-  const genreKey  = `genre:${detectGenre(track)}`;
+  const genreKey = `genre:${detectGenre(track)}`;
   state.skipSignals[artistKey] = Math.min((state.skipSignals[artistKey] || 0) + 1, 10);
   if (detectGenre(track) !== 'general') {
     state.skipSignals[genreKey] = Math.min((state.skipSignals[genreKey] || 0) + 1, 10);
@@ -999,11 +999,11 @@ function recordSkipSignal(track) {
 // ===== P6: Time-of-Day Context =====
 function getTimeOfDayContext() {
   const h = new Date().getHours();
-  if (h >= 5  && h < 9)  return { label: 'Morning',   icon: 'ðŸŒ…', queries: ['devotional morning songs', 'classical peaceful', 'bhakti songs soft'] };
-  if (h >= 9  && h < 13) return { label: 'Focus',     icon: 'ðŸŽ¯', queries: ['instrumental focus music', 'acoustic calm light', 'soft concentration'] };
+  if (h >= 5 && h < 9) return { label: 'Morning', icon: 'ðŸŒ…', queries: ['devotional morning songs', 'classical peaceful', 'bhakti songs soft'] };
+  if (h >= 9 && h < 13) return { label: 'Focus', icon: 'ðŸŽ¯', queries: ['instrumental focus music', 'acoustic calm light', 'soft concentration'] };
   if (h >= 13 && h < 17) return { label: 'Afternoon', icon: 'â˜€ï¸', queries: ['peppy upbeat trending', 'latest hits energy', 'dance remix popular'] };
-  if (h >= 17 && h < 21) return { label: 'Evening',   icon: 'ðŸŒ†', queries: ['romantic evening songs', 'mood chill relax', 'feel good music'] };
-  return                         { label: 'Night',     icon: 'ðŸŒ™', queries: ['slow romantic night', 'soft lullaby soothing', 'chill lofi night'] };
+  if (h >= 17 && h < 21) return { label: 'Evening', icon: 'ðŸŒ†', queries: ['romantic evening songs', 'mood chill relax', 'feel good music'] };
+  return { label: 'Night', icon: 'ðŸŒ™', queries: ['slow romantic night', 'soft lullaby soothing', 'chill lofi night'] };
 }
 
 // ===== UNIFIED AUTO DJ ENGINE =====
@@ -1012,37 +1012,37 @@ function getTimeOfDayContext() {
 // DJ mixer: auto-fill decks + auto-mix (separate djMixer.toggleAutoDJ).
 
 const SMART_DJ_VIBES = {
-  auto:     { label: 'Auto',         icon: 'ðŸ•', queries: null },           // time-based
-  morning:  { label: 'Morning Raga', icon: 'ðŸŒ…', queries: ['devotional morning', 'classical acoustic peaceful', 'bhakti soft'] },
-  focus:    { label: 'Focus',        icon: 'ðŸŽ¯', queries: ['instrumental focus', 'acoustic calm lofi', 'study concentration'] },
-  workout:  { label: 'Workout',      icon: 'ðŸ’ª', queries: ['dance remix energetic', 'party beats fast', 'high energy songs'] },
-  party:    { label: 'Party',        icon: 'ðŸŽ‰', queries: ['party remix hits', 'dance floor peppy', 'upbeat dj songs'] },
-  chill:    { label: 'Chill',        icon: 'ðŸ˜Ž', queries: ['chill lofi soft', 'mellow acoustic calm', 'relax songs slow'] },
-  romantic: { label: 'Romantic',     icon: 'ðŸ’•', queries: ['romantic love songs', 'pyar heart touching', 'love ballad'] },
-  winddown: { label: 'Wind Down',    icon: 'ðŸŒ™', queries: ['slow soothing night', 'soft lullaby peaceful', 'classical slow'] }
+  auto: { label: 'Auto', icon: 'ðŸ•', queries: null },           // time-based
+  morning: { label: 'Morning Raga', icon: 'ðŸŒ…', queries: ['devotional morning', 'classical acoustic peaceful', 'bhakti soft'] },
+  focus: { label: 'Focus', icon: 'ðŸŽ¯', queries: ['instrumental focus', 'acoustic calm lofi', 'study concentration'] },
+  workout: { label: 'Workout', icon: 'ðŸ’ª', queries: ['dance remix energetic', 'party beats fast', 'high energy songs'] },
+  party: { label: 'Party', icon: 'ðŸŽ‰', queries: ['party remix hits', 'dance floor peppy', 'upbeat dj songs'] },
+  chill: { label: 'Chill', icon: 'ðŸ˜Ž', queries: ['chill lofi soft', 'mellow acoustic calm', 'relax songs slow'] },
+  romantic: { label: 'Romantic', icon: 'ðŸ’•', queries: ['romantic love songs', 'pyar heart touching', 'love ballad'] },
+  winddown: { label: 'Wind Down', icon: 'ðŸŒ™', queries: ['slow soothing night', 'soft lullaby peaceful', 'classical slow'] }
 };
 
 // â”€â”€â”€ DJ SESSION: Energy Arcs & Pool Queries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // Energy arc templates: arrays of target energy levels (0=chill, 1=med, 2=high, 3=peak)
 // Each position = one track in the setlist
 const ENERGY_ARCS = {
-  party:    [1, 1, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 2, 2, 1, 1],
-  workout:  [2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 2, 2],
-  morning:  [0, 0, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0],
-  focus:    [1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
-  chill:    [0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1],
+  party: [1, 1, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 2, 2, 1, 1],
+  workout: [2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 2, 2],
+  morning: [0, 0, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0],
+  focus: [1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
+  chill: [0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1],
   romantic: [1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1],
   winddown: [2, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
-  auto:     null  // generated from time of day
+  auto: null  // generated from time of day
 };
 
 // Pool queries per vibe â€” 5 diverse queries each, fetched in parallel for ~100 songs
 const DJ_POOL_QUERIES = {
-  party:    ['party remix energetic', 'dance hits fast beat', 'dj songs club night', 'upbeat peppy trending', 'bhangra dance remix'],
-  workout:  ['gym workout power songs', 'high energy fast beat', 'running motivation songs', 'pump up remix', 'energetic exercise songs'],
-  morning:  ['morning fresh devotional', 'bhakti songs soft', 'classical peaceful morning', 'light acoustic fresh start', 'sunrise peaceful songs'],
-  focus:    ['instrumental concentration', 'acoustic study calm lofi', 'soft background focus', 'light instrumental work', 'calm ambient peaceful'],
-  chill:    ['chill lofi soft relax', 'mellow slow acoustic', 'easy listening soothing', 'soft night chill', 'peaceful slow mood'],
+  party: ['party remix energetic', 'dance hits fast beat', 'dj songs club night', 'upbeat peppy trending', 'bhangra dance remix'],
+  workout: ['gym workout power songs', 'high energy fast beat', 'running motivation songs', 'pump up remix', 'energetic exercise songs'],
+  morning: ['morning fresh devotional', 'bhakti songs soft', 'classical peaceful morning', 'light acoustic fresh start', 'sunrise peaceful songs'],
+  focus: ['instrumental concentration', 'acoustic study calm lofi', 'soft background focus', 'light instrumental work', 'calm ambient peaceful'],
+  chill: ['chill lofi soft relax', 'mellow slow acoustic', 'easy listening soothing', 'soft night chill', 'peaceful slow mood'],
   romantic: ['romantic love songs', 'pyar heart touching melody', 'love ballad duet', 'slow romantic night', 'emotional love songs'],
   winddown: ['slow soothing night songs', 'lullaby soft sleep', 'peaceful bedtime classical', 'calm gentle night', 'slow melodious wind down'],
   trending: ['trending songs 2025 latest', 'top hits popular', 'viral songs most played', 'new release hot', 'chartbuster hits']
@@ -1050,10 +1050,10 @@ const DJ_POOL_QUERIES = {
 
 // Energy level visual labels and colours used in arc strips
 const ENERGY_META = [
-  { label: 'Chill',  color: '#06b6d4', bg: 'rgba(6,182,212,0.15)'  },  // 0
-  { label: 'Medium', color: '#22c55e', bg: 'rgba(34,197,94,0.15)'  },  // 1
-  { label: 'High',   color: '#f59e0b', bg: 'rgba(245,158,11,0.15)' },  // 2
-  { label: 'Peak',   color: '#ef4444', bg: 'rgba(239,68,68,0.15)'  },  // 3
+  { label: 'Chill', color: '#06b6d4', bg: 'rgba(6,182,212,0.15)' },  // 0
+  { label: 'Medium', color: '#22c55e', bg: 'rgba(34,197,94,0.15)' },  // 1
+  { label: 'High', color: '#f59e0b', bg: 'rgba(245,158,11,0.15)' },  // 2
+  { label: 'Peak', color: '#ef4444', bg: 'rgba(239,68,68,0.15)' },  // 3
 ];
 
 // Energy levels for progression-aware mixing (0=low â†’ 3=peak)
@@ -1130,7 +1130,7 @@ async function _autoDJBootstrap() {
     state.queueIndex = 0;
     playSong(results[0], false);
     renderQueue();
-  } catch(e) { console.warn('[Auto DJ bootstrap]', e); }
+  } catch (e) { console.warn('[Auto DJ bootstrap]', e); }
 }
 
 function stopAutoDJMode() {
@@ -1218,10 +1218,10 @@ async function buildSmartDJQueue() {
     const results = await apiSearch(searchQuery, 25);
     if (!results.length) return;
 
-    const playedIds  = new Set(state.playedTracks.map(t => t.id));
+    const playedIds = new Set(state.playedTracks.map(t => t.id));
     const existingIds = new Set(state.queue.map(t => t.id));
     const fresh = results.filter(t => !playedIds.has(t.id) && !existingIds.has(t.id));
-    const pool  = fresh.length >= 5 ? fresh : results.filter(t => !existingIds.has(t.id));
+    const pool = fresh.length >= 5 ? fresh : results.filter(t => !existingIds.has(t.id));
     if (!pool.length) return;
 
     // Score using similarity + energy matching + anti-clustering
@@ -1267,7 +1267,7 @@ async function buildSmartDJQueue() {
     const vibe = SMART_DJ_VIBES[state.smartDJVibe];
     const timeLabel = vibe?.label === 'Auto' ? getTimeOfDayContext().label : vibe?.label;
     showToast(`Auto DJ: ${picks.length} tracks queued Â· ${vibe?.icon || 'ðŸŽ§'} ${timeLabel}`);
-  } catch(e) {
+  } catch (e) {
     console.warn('[Auto DJ]', e);
   } finally {
     state.smartDJBusy = false;
@@ -1334,7 +1334,7 @@ async function generateDailyMixes() {
   try {
     const stored = JSON.parse(localStorage.getItem('raagam_daily_mixes') || 'null');
     if (stored?.date === today && stored?.mixes?.length) return stored.mixes;
-  } catch(e) {}
+  } catch (e) { }
   const lang = CONFIG.preferredLanguage || 'hindi';
   const ld = CONFIG.supportedLanguages[lang];
   const lk = ld?.keywords[0] || 'hindi';
@@ -1383,7 +1383,7 @@ async function renderDailyMixes() {
   if (!container) return;
 
   // Show skeleton cards instantly while we validate each mix has real tracks
-  container.innerHTML = [0,1,2,3,4].map(() => `
+  container.innerHTML = [0, 1, 2, 3, 4].map(() => `
     <div style="flex-shrink:0;width:140px">
       <div class="skeleton skeleton-card" style="height:140px;border-radius:12px"></div>
       <div class="skeleton skeleton-text" style="width:80%;margin-top:8px"></div>
@@ -1419,10 +1419,10 @@ async function renderDailyMixes() {
     // Cache validated mixes for the rest of the day
     try {
       localStorage.setItem(cacheKey, JSON.stringify({ date: today, mixes: validMixes }));
-    } catch {}
+    } catch { }
 
     _renderValidatedMixCards(container, validMixes);
-  } catch(e) {
+  } catch (e) {
     console.warn('[Daily Mixes]', e);
     container.innerHTML = '<p style="color:var(--text-dim);font-size:13px;padding:20px;text-align:center">Daily mixes unavailable. Check your connection.</p>';
   }
@@ -1456,7 +1456,7 @@ function _renderValidatedMixCards(container, mixes) {
           const more = await apiSearch(mix.query, 15);
           const existIds = new Set(tracks.map(t => t.id));
           tracks = [...tracks, ...more.filter(t => !existIds.has(t.id))];
-        } catch {}
+        } catch { }
       }
       if (!tracks.length) { showToast('Could not load mix'); return; }
       state.queue = tracks; state.queueIndex = 0;
@@ -1614,10 +1614,10 @@ async function loadHome() {
   if (bollywoodTitle) bollywoodTitle.textContent = lang === 'hindi' ? 'Bollywood Party Mix' : 'Bollywood Vibes';
 
   const sections = [
-    { id: 'trending-row',  query: `trending ${langName} songs ${currentYear}` },
-    { id: 'language-row',  query: `new ${langName} songs ${currentYear} latest` },
+    { id: 'trending-row', query: `trending ${langName} songs ${currentYear}` },
+    { id: 'language-row', query: `new ${langName} songs ${currentYear} latest` },
     { id: 'bollywood-row', query: lang === 'hindi' ? `bollywood party songs ${currentYear}` : `bollywood top hits ${currentYear}` },
-    { id: 'chill-row',     query: 'chill lofi relax' },
+    { id: 'chill-row', query: 'chill lofi relax' },
   ];
 
   // Try today's cache â€” renders instantly with zero API calls
@@ -1661,7 +1661,7 @@ async function loadHome() {
     }
   });
 
-  try { localStorage.setItem(sectionCacheKey, JSON.stringify(toCache)); } catch {}
+  try { localStorage.setItem(sectionCacheKey, JSON.stringify(toCache)); } catch { }
 
   state.homeLoaded = true;
 }
@@ -1672,7 +1672,7 @@ async function _refreshHomeSections(sections, cacheKey) {
     const results = await Promise.all(sections.map(s => apiSearch(s.query, 15)));
     const toCache = results.map(tracks => (tracks.length ? tracks : []));
     localStorage.setItem(cacheKey, JSON.stringify(toCache));
-  } catch {}
+  } catch { }
 }
 
 // ===== Search =====
@@ -2513,15 +2513,15 @@ const equalizer = {
   connected: false,
 
   presets: {
-    'off':           { bass: 0,  mid: 0,  treble: 0 },
-    'bass-boost':    { bass: 8,  mid: 1,  treble: -1 },
-    'treble-boost':  { bass: -1, mid: 0,  treble: 7 },
-    'vocal':         { bass: -3, mid: 6,  treble: 3 },
-    'rock':          { bass: 5,  mid: -2, treble: 4 },
-    'pop':           { bass: 2,  mid: 4,  treble: 2 },
-    'classical':     { bass: 0,  mid: 0,  treble: -2 },
-    'jazz':          { bass: 3,  mid: 2,  treble: 4 },
-    'electronic':    { bass: 7,  mid: 0,  treble: 5 }
+    'off': { bass: 0, mid: 0, treble: 0 },
+    'bass-boost': { bass: 8, mid: 1, treble: -1 },
+    'treble-boost': { bass: -1, mid: 0, treble: 7 },
+    'vocal': { bass: -3, mid: 6, treble: 3 },
+    'rock': { bass: 5, mid: -2, treble: 4 },
+    'pop': { bass: 2, mid: 4, treble: 2 },
+    'classical': { bass: 0, mid: 0, treble: -2 },
+    'jazz': { bass: 3, mid: 2, treble: 4 },
+    'electronic': { bass: 7, mid: 0, treble: 5 }
   },
 
   init() {
@@ -2958,7 +2958,7 @@ async function requestWakeLock() {
 
 function releaseWakeLock() {
   if (state.alarmWakeLock) {
-    try { state.alarmWakeLock.release(); } catch (e) {}
+    try { state.alarmWakeLock.release(); } catch (e) { }
     state.alarmWakeLock = null;
   }
 }
@@ -3000,7 +3000,7 @@ async function triggerAlarm() {
 
   // Try to resume audio context
   if (equalizer.context && equalizer.context.state === 'suspended') {
-    try { await equalizer.context.resume(); } catch(e) {}
+    try { await equalizer.context.resume(); } catch (e) { }
   }
 
   // Set autoplay mode if requested
@@ -3122,7 +3122,7 @@ function initAlarmOnLoad() {
         state.alarm = alarmData;
         triggerAlarm();
       }
-    } catch(e) {
+    } catch (e) {
       localStorage.removeItem('raagam_alarm');
     }
   }
@@ -4069,14 +4069,14 @@ function startCrossfade() {
       try {
         const src2 = equalizer.context.createMediaElementSource(state.crossfadeAudio);
         src2.connect(equalizer.filters.bass);
-      } catch(e) { /* may already be connected */ }
+      } catch (e) { /* may already be connected */ }
     }
   }
 
   state.crossfadeAudio.src = nextUrl;
   state.crossfadeAudio.volume = 0;
   state.crossfadeAudio.playbackRate = state.playbackSpeed;
-  state.crossfadeAudio.play().catch(() => {});
+  state.crossfadeAudio.play().catch(() => { });
 
   const dur = state.crossfadeDuration * 1000;
   const steps = 20;
@@ -4102,7 +4102,7 @@ function startCrossfade() {
       audio.src = nextUrl;
       audio.volume = originalVolume;
       audio.playbackRate = state.playbackSpeed;
-      audio.play().catch(() => {});
+      audio.play().catch(() => { });
 
       state.crossfadeAudio.pause();
       state.crossfadeAudio.src = '';
@@ -4588,15 +4588,15 @@ const djMixer = {
     const peaks = [];
     for (let i = 1; i < deck._bpmSamples.length - 1; i++) {
       if (deck._bpmSamples[i].energy > avg * 1.3 &&
-          deck._bpmSamples[i].energy > deck._bpmSamples[i-1].energy &&
-          deck._bpmSamples[i].energy > deck._bpmSamples[i+1].energy) {
+        deck._bpmSamples[i].energy > deck._bpmSamples[i - 1].energy &&
+        deck._bpmSamples[i].energy > deck._bpmSamples[i + 1].energy) {
         peaks.push(deck._bpmSamples[i].time);
       }
     }
     if (peaks.length < 4) return deck.bpmEstimate;
     // Average interval between peaks
     let totalInterval = 0;
-    for (let i = 1; i < peaks.length; i++) totalInterval += peaks[i] - peaks[i-1];
+    for (let i = 1; i < peaks.length; i++) totalInterval += peaks[i] - peaks[i - 1];
     const avgInterval = totalInterval / (peaks.length - 1);
     if (avgInterval > 0) {
       deck.bpmEstimate = Math.round(60000 / avgInterval);
@@ -4915,10 +4915,10 @@ const djMixer = {
     // Build an intelligent query from the reference track's genre + mood
     let queries = [];
     if (refTrack) {
-      const genre  = detectGenre(refTrack);
-      const mood   = detectMood(refTrack);
+      const genre = detectGenre(refTrack);
+      const mood = detectMood(refTrack);
       const artist = getArtistName(refTrack);
-      const title  = getTrackName(refTrack);
+      const title = getTrackName(refTrack);
 
       // Primary: same genre + language
       if (genre !== 'general') queries.push(`${langKeyword} ${genre} songs`);
@@ -4957,8 +4957,8 @@ const djMixer = {
         // Score each candidate using the full similarity scorer (includes skip penalties)
         const scored = refTrack
           ? available
-              .map(t => ({ ...t, _score: calculateSimilarityScore(refTrack, t, detectLanguage(refTrack), detectGenre(refTrack)) }))
-              .sort((a, b) => b._score - a._score)
+            .map(t => ({ ...t, _score: calculateSimilarityScore(refTrack, t, detectLanguage(refTrack), detectGenre(refTrack)) }))
+            .sort((a, b) => b._score - a._score)
           : available;
 
         const best = scored[0];
@@ -5017,8 +5017,8 @@ const djMixer = {
       const avgE = arc.reduce((s, e) => s + e, 0) / arc.length;
       const arcShape = avgE >= 2.5 ? 'Sustained peak energy'
         : avgE >= 1.8 ? 'Build-up to high energy'
-        : avgE >= 1.2 ? 'Balanced energy flow'
-        : 'Relaxed, low-energy flow';
+          : avgE >= 1.2 ? 'Balanced energy flow'
+            : 'Relaxed, low-energy flow';
       desc.textContent = `${vibeLabel} Â· ${count === 0 ? 'Infinite' : count + ' tracks'} Â· ${arcShape}`;
     }
   },
@@ -5029,11 +5029,11 @@ const djMixer = {
     if (!base) {
       // Auto: derive from time of day
       const h = new Date().getHours();
-      if      (h >= 5  && h < 9)  base = ENERGY_ARCS.morning;
-      else if (h >= 9  && h < 13) base = ENERGY_ARCS.focus;
+      if (h >= 5 && h < 9) base = ENERGY_ARCS.morning;
+      else if (h >= 9 && h < 13) base = ENERGY_ARCS.focus;
       else if (h >= 13 && h < 17) base = ENERGY_ARCS.party;
       else if (h >= 17 && h < 21) base = ENERGY_ARCS.romantic;
-      else                         base = ENERGY_ARCS.winddown;
+      else base = ENERGY_ARCS.winddown;
     }
     if (count === 0) return [...base]; // infinite â€” just use the template
     // Extend or trim to requested count by repeating the arc pattern
@@ -5062,17 +5062,17 @@ const djMixer = {
     }
 
     // Build the pre-planned setlist from pool + energy arc
-    const arc    = this._getArcForVibe(cfg.vibe, cfg.songCount || 20);
+    const arc = this._getArcForVibe(cfg.vibe, cfg.songCount || 20);
     const setlist = this.buildDJSetlist(pool, arc);
 
     // Save session state
     state.djSession = {
-      config:       cfg,
-      pool:         pool,
-      setlist:      setlist,
-      setlistIdx:   0,
+      config: cfg,
+      pool: pool,
+      setlist: setlist,
+      setlistIdx: 0,
       poolFetchedAt: Date.now(),
-      usedIds:      new Set()
+      usedIds: new Set()
     };
 
     // Eject existing deck tracks, load first 2 from setlist onto decks
@@ -5152,7 +5152,7 @@ const djMixer = {
         const scored = candidates.map(t => ({
           ...t,
           _score: calculateSimilarityScore(prevTrack, t, detectLanguage(prevTrack), detectGenre(prevTrack))
-                  + (getEnergyLevel(t) === targetEnergy ? 20 : 0)  // bonus for exact energy match
+            + (getEnergyLevel(t) === targetEnergy ? 20 : 0)  // bonus for exact energy match
         })).sort((a, b) => b._score - a._score);
         best = scored[0];
       } else {
@@ -5276,16 +5276,16 @@ const djMixer = {
 
     // Render arc bars â€” show window of 30 around current position
     const windowStart = Math.max(0, setlistIdx - 5);
-    const windowEnd   = Math.min(setlist.length, windowStart + 30);
+    const windowEnd = Math.min(setlist.length, windowStart + 30);
     const slice = setlist.slice(windowStart, windowEnd);
 
     barsRow.innerHTML = slice.map((slot, i) => {
       const absIdx = windowStart + i;
       const e = slot.energyTarget;
       const m = ENERGY_META[e];
-      const isPast    = absIdx < setlistIdx - 1;
+      const isPast = absIdx < setlistIdx - 1;
       const isCurrent = absIdx === setlistIdx - 1;
-      const isFuture  = absIdx >= setlistIdx;
+      const isFuture = absIdx >= setlistIdx;
       const h = 10 + e * 10; // height 10-40px
       const name = slot.track ? getTrackName(slot.track).slice(0, 12) : '...';
       return `<div class="dj-arc-bar${isCurrent ? ' dj-arc-bar-current' : ''}${isPast ? ' dj-arc-bar-past' : ''}"
@@ -5498,7 +5498,7 @@ const djMixer = {
     const assignA = state.djCrossfaderAssign.a;
     const assignB = state.djCrossfaderAssign.b;
     const onCrossfader = (outIdx === assignA && nextIdx === assignB) ||
-                         (outIdx === assignB && nextIdx === assignA);
+      (outIdx === assignB && nextIdx === assignA);
     if (onCrossfader) {
       // Sweep hardware crossfader to next-deck side over 4s
       const targetPos = nextIdx === assignB ? 100 : 0;
@@ -6007,7 +6007,7 @@ const djMixer = {
       const fillCircle = el.querySelector('.dj-rotary-fill');
       const pointer = el.querySelector('.dj-rotary-pointer');
       const valLabel = el.querySelector('.dj-rotary-val') ||
-                       el.closest('.dj-rotary-group')?.querySelector('.dj-rotary-val');
+        el.closest('.dj-rotary-group')?.querySelector('.dj-rotary-val');
       if (fillCircle) fillCircle.style.strokeDashoffset = offset;
       if (pointer) pointer.style.transform = `rotate(${angleDeg}deg)`;
       if (pointer) pointer.style.transformOrigin = '32px 32px';
@@ -7800,66 +7800,84 @@ let appInitialized = false;
 function init() {
   console.log('init() called');
 
-  // Check if profile is set up
-  if (!state.userProfile) {
-    console.log('Profile not set up, showing profile dialog');
-    showProfileDialog();
-    return;
-  }
+  try {
+    // Check if profile is set up
+    if (!state.userProfile) {
+      console.log('Profile not set up, showing profile dialog');
+      showProfileDialog();
+      return;
+    }
 
-  // Check if language setup is needed
-  if (!state.languageSetupComplete) {
-    // Default to hindi if no language was set (e.g. old users upgrading)
-    if (!CONFIG.preferredLanguage) {
-      CONFIG.preferredLanguage = 'hindi';
-      localStorage.setItem('raagam_language', 'hindi');
+    // Check if language setup is needed
+    if (!state.languageSetupComplete) {
+      // Default to hindi if no language was set (e.g. old users upgrading)
+      if (!CONFIG.preferredLanguage) {
+        CONFIG.preferredLanguage = 'hindi';
+        localStorage.setItem('raagam_language', 'hindi');
+      }
+      localStorage.setItem('raagam_language_setup', 'true');
+      state.languageSetupComplete = true;
     }
-    localStorage.setItem('raagam_language_setup', 'true');
-    state.languageSetupComplete = true;
-  }
 
-  // Show app and remove splash
-  const splashEl = $('#splash');
-  const appEl = $('#app');
-  if (appEl) appEl.classList.remove('hidden');
-  if (splashEl) {
-    splashEl.style.opacity = '0';
-    splashEl.style.transition = 'opacity 0.4s ease';
-    setTimeout(() => splashEl.remove(), 500);
-  }
-  updateGreeting();
+    // Show app and remove splash
+    const splashEl = $('#splash');
+    const appEl = $('#app');
+    if (appEl) appEl.classList.remove('hidden');
+    if (splashEl) {
+      splashEl.style.opacity = '0';
+      splashEl.style.transition = 'opacity 0.4s ease';
+      setTimeout(() => splashEl.remove(), 500);
+    }
+    updateGreeting();
 
-  // Only set up events once
-  if (!appInitialized) {
-    appInitialized = true;
-    setupEvents();
-    setupSearch();
-    setupLibrary();
+    // Only set up events once
+    if (!appInitialized) {
+      appInitialized = true;
+      try {
+        setupEvents();
+        setupSearch();
+        setupLibrary();
+      } catch (err) {
+        console.error('Error setting up core events:', err);
+      }
 
-    // Restore saved playback speed
-    if (state.playbackSpeed !== 1) {
-      audio.playbackRate = state.playbackSpeed;
-      const speedLabel = $('#speed-label');
-      if (speedLabel) speedLabel.textContent = `${state.playbackSpeed}x`;
-    }
+      // Restore saved playback speed
+      try {
+        if (state.playbackSpeed !== 1) {
+          audio.playbackRate = state.playbackSpeed;
+          const speedLabel = $('#speed-label');
+          if (speedLabel) speedLabel.textContent = `${state.playbackSpeed}x`;
+        }
+      } catch (e) { console.warn('Speed restore failed', e); }
+
+      // Restore alarm if active
+      try { initAlarmOnLoad(); } catch (e) { console.warn('Alarm restore failed', e); }
 
-    // Restore alarm if active
-    initAlarmOnLoad();
+      // Restore theme
+      try {
+        applyTheme(state.currentTheme, false);
+        setupThemePicker();
+      } catch (e) { console.warn('Theme restore failed', e); }
 
-    // Restore theme
-    applyTheme(state.currentTheme, false);
-    setupThemePicker();
+      // Show feature tour for first-time users (after a short delay so UI loads)
+      if (!localStorage.getItem('raagam_feature_tour_seen')) {
+        setTimeout(() => showFeatureTour(), 1200);
+      }
 
-    // Show feature tour for first-time users (after a short delay so UI loads)
-    if (!localStorage.getItem('raagam_feature_tour_seen')) {
-      setTimeout(() => showFeatureTour(), 1200);
+      // Settings: Features button
+      const featuresBtn = $('#settings-features-btn');
+      if (featuresBtn) featuresBtn.addEventListener('click', () => showFeatureTour());
     }
-
-    // Settings: Features button
-    const featuresBtn = $('#settings-features-btn');
-    if (featuresBtn) featuresBtn.addEventListener('click', () => showFeatureTour());
+    loadHome();
+  } catch (criticalError) {
+    console.error('CRITICAL INIT ERROR:', criticalError);
+    // Last ditch effort to show UI
+    const appEl = $('#app');
+    if (appEl) appEl.classList.remove('hidden');
+    const splashEl = $('#splash');
+    if (splashEl) splashEl.remove();
+    showToast('App recovered from error. Please clear data if issues persist.');
   }
-  loadHome();
 }
 
 // ===== USER PROFILES =====
@@ -7876,8 +7894,18 @@ function initUserProfiles() {
   if (!parsed && savedAlt) {
     try { parsed = JSON.parse(savedAlt); } catch (e) { parsed = null; }
   }
+
+  // Robust merge: ensure all required fields exist even if loaded profile is partial
+  const defaults = createDefaultProfile();
+
   if (parsed) {
-    state.userProfile = parsed;
+    // Deep merge stats and preferences to prevent crashes on missing keys
+    state.userProfile = {
+      ...defaults,
+      ...parsed,
+      stats: { ...defaults.stats, ...(parsed.stats || {}) },
+      preferences: { ...defaults.preferences, ...(parsed.preferences || {}) }
+    };
   } else {
     state.userProfile = null; // No profile: trigger onboarding dialog
   }
@@ -7912,6 +7940,10 @@ function createDefaultProfile() {
 
 function updateProfileStats() {
   if (!state.userProfile) return;
+  // Guard against missing stats object
+  if (!state.userProfile.stats) {
+    state.userProfile.stats = createDefaultProfile().stats;
+  }
 
   // Update play time
   if (state.currentSong && state.isPlaying) {
@@ -7930,7 +7962,7 @@ function updateProfileStats() {
     });
 
     const sortedArtists = Object.entries(artistCounts)
-      .sort(([,a], [,b]) => b - a)
+      .sort(([, a], [, b]) => b - a)
       .slice(0, 5)
       .map(([artist]) => artist);
 
@@ -8143,8 +8175,8 @@ const autoBackup = {
           db.createObjectStore('kv', { keyPath: 'k' });
         }
       };
-      req.onsuccess  = (e) => { this._db = e.target.result; resolve(this._db); };
-      req.onerror    = ()  => reject(req.error);
+      req.onsuccess = (e) => { this._db = e.target.result; resolve(this._db); };
+      req.onerror = () => reject(req.error);
     });
   },
 
@@ -8153,7 +8185,7 @@ const autoBackup = {
       const db = await this._open();
       const tx = db.transaction('kv', 'readwrite');
       tx.objectStore('kv').put({ k: key, v: value, t: Date.now() });
-    } catch {}
+    } catch { }
   },
 
   async _get(key) {
@@ -8163,7 +8195,7 @@ const autoBackup = {
         const tx = db.transaction('kv', 'readonly');
         const req = tx.objectStore('kv').get(key);
         req.onsuccess = () => resolve(req.result?.v ?? null);
-        req.onerror   = () => resolve(null);
+        req.onerror = () => resolve(null);
       });
     } catch { return null; }
   },
@@ -8176,15 +8208,15 @@ const autoBackup = {
 
   async _saveAll() {
     await this._put('snapshot', {
-      profile:        state.userProfile,
-      language:       CONFIG.preferredLanguage,
-      liked:          state.liked,
-      playlists:      state.playlists,
-      recent:         state.recent.slice(0, 50),
+      profile: state.userProfile,
+      language: CONFIG.preferredLanguage,
+      liked: state.liked,
+      playlists: state.playlists,
+      recent: state.recent.slice(0, 50),
       favoriteGenres: state.favoriteGenres,
-      skipSignals:    state.skipSignals,
-      theme:          state.currentTheme,
-      savedAt:        Date.now(),
+      skipSignals: state.skipSignals,
+      theme: state.currentTheme,
+      savedAt: Date.now(),
     });
   },
 
@@ -8226,8 +8258,8 @@ const autoBackup = {
 
     if (restored) {
       state.homeLoaded = false;
-      try { updateLikeButtons(); }    catch(_) {}
-      try { updateLibraryCounts(); }  catch(_) {}
+      try { updateLikeButtons(); } catch (_) { }
+      try { updateLibraryCounts(); } catch (_) { }
       console.log('[AutoBackup] Restored profile from IndexedDB');
     }
     return restored;
@@ -8236,20 +8268,20 @@ const autoBackup = {
   // Export profile as a downloadable JSON file
   exportJSON() {
     const data = {
-      version:   1,
+      version: 1,
       exportedAt: new Date().toISOString(),
-      profile:   state.userProfile,
-      language:  CONFIG.preferredLanguage,
-      liked:     state.liked,
+      profile: state.userProfile,
+      language: CONFIG.preferredLanguage,
+      liked: state.liked,
       playlists: state.playlists,
-      recent:    state.recent.slice(0, 50),
-      theme:     state.currentTheme,
+      recent: state.recent.slice(0, 50),
+      theme: state.currentTheme,
     };
     const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
-    const url  = URL.createObjectURL(blob);
-    const a    = document.createElement('a');
-    a.href     = url;
-    a.download = `raagam-profile-${new Date().toISOString().slice(0,10)}.json`;
+    const url = URL.createObjectURL(blob);
+    const a = document.createElement('a');
+    a.href = url;
+    a.download = `raagam-profile-${new Date().toISOString().slice(0, 10)}.json`;
     a.click();
     URL.revokeObjectURL(url);
   },
@@ -8283,7 +8315,7 @@ const autoBackup = {
           state.homeLoaded = false;
           autoBackup.schedule();
           resolve(data);
-        } catch(err) { reject(err); }
+        } catch (err) { reject(err); }
       };
       reader.onerror = () => reject(reader.error);
       reader.readAsText(file);
@@ -8348,7 +8380,7 @@ function _initProfileBackupUI() {
       showToast('Profile imported! Home is refreshingâ€¦');
       state.homeLoaded = false;
       loadHome();
-    } catch(err) {
+    } catch (err) {
       showToast('Import failed â€” invalid file');
     }
     e.target.value = ''; // reset so same file can be re-selected
@@ -8359,7 +8391,7 @@ function _initProfileBackupUI() {
     const el = document.getElementById('profile-backup-info');
     if (!el || !snap?.savedAt) return;
     const d = new Date(snap.savedAt);
-    el.textContent = `Last backup: ${d.toLocaleDateString()} ${d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
+    el.textContent = `Last backup: ${d.toLocaleDateString()} ${d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
   });
 }
 
@@ -9290,7 +9322,7 @@ function addDownloadButtonToResult(resultItem, track) {
 
 // Override playSong to support offline tracks
 const originalPlaySong = playSong;
-playSong = async function(track, addToQueue = true) {
+playSong = async function (track, addToQueue = true) {
   // Check if offline mode and track is downloaded
   if (state.offlineMode && state.offlineTracks.has(track.id)) {
     const offlineTrack = await getOfflineTrack(track.id);
@@ -9370,7 +9402,7 @@ document.addEventListener('DOMContentLoaded', () => {
   // Runs async before init() â€” profile data is available when home renders.
   autoBackup.restore().then(restored => {
     if (restored) showToast('Profile restored from backup');
-  }).catch(() => {});
+  }).catch(() => { });
 
   init();
 
@@ -9379,14 +9411,14 @@ document.addEventListener('DOMContentLoaded', () => {
   // may have failed to attach event listeners, which would otherwise leave a black screen.
   function _uiRecovery(hard) {
     try {
-      const appEl  = $('#app');
+      const appEl = $('#app');
       const splash = $('#splash');
-      const pdlg   = $('#profile-dialog');
-      const ldlg   = $('#language-dialog');
+      const pdlg = $('#profile-dialog');
+      const ldlg = $('#language-dialog');
       if (!appEl || !appEl.classList.contains('hidden')) return; // already visible
 
       const dialogsHidden = (!pdlg || pdlg.classList.contains('hidden')) &&
-                            (!ldlg || ldlg.classList.contains('hidden'));
+        (!ldlg || ldlg.classList.contains('hidden'));
 
       if (dialogsHidden || hard) {
         // Hide any stuck dialogs on hard recovery
@@ -9407,7 +9439,7 @@ document.addEventListener('DOMContentLoaded', () => {
         appEl.classList.remove('hidden');
         if (splash) { splash.style.opacity = '0'; setTimeout(() => splash.remove(), 400); }
         if (!appInitialized) {
-          try { setupEvents(); setupSearch(); setupLibrary(); loadHome(); } catch (_) {}
+          try { setupEvents(); setupSearch(); setupLibrary(); loadHome(); } catch (_) { }
         }
         if (hard) showToast('App recovered â€” if issues persist, go to Settings â†’ Clear Data');
       }
@@ -9417,7 +9449,7 @@ document.addEventListener('DOMContentLoaded', () => {
   }
   setTimeout(() => _uiRecovery(false), 1500);  // soft: only fires if no dialog visible
   setTimeout(() => _uiRecovery(false), 4000);  // second soft attempt
-  setTimeout(() => _uiRecovery(true),  8000);  // hard: clears stuck dialogs, forces show
+  setTimeout(() => _uiRecovery(true), 8000);  // hard: clears stuck dialogs, forces show
 });
 
 // ===== bfcache fix =====

commit 0740715f730ed443cd67b713e804bdab1bbf2c49
Author: Claude <noreply@anthropic.com>
Date:   Thu Feb 19 02:16:22 2026 +0000

    Remove GitHub requirement â€” profile auto-saves to IndexedDB on first name entry
    
    Problem: Previous cloud sync required users to visit GitHub to get a token.
    Solution: Fully automatic profile backup with zero user action.
    
    Profile lifecycle:
    - User enters name â†’ profile saved to localStorage â†’ autoBackup.schedule() fires
      â†’ profile written to IndexedDB 2.5s later, silently
    - navigator.storage.persist() requested so iOS never purges the data after 7 days
    - Every like/unlike and stat update triggers autoBackup.schedule() (debounced 2.5s)
    
    On every app open:
    - autoBackup.restore() runs before init() â€” if localStorage is empty (purged by iOS)
      it restores liked songs, playlists, history, language, theme from IndexedDB
    - Home loads with full personalized content: Quick Picks from history, Daily Mix
      from liked artists â€” all without any user action
    
    Settings â†’ Profile & Backup:
    - Shows "Auto-saved" badge (always on, nothing to configure)
    - Export Profile: downloads raagam-profile-YYYY-MM-DD.json
    - Import Profile: pick a JSON file â†’ merges liked songs, playlists, history
    
    Cross-device: user exports on device A, imports on device B â€” 2 taps, no accounts
    
    Also removed: GitHub Gist profileSync object, _initCloudSyncUI, _refreshCloudSyncUI,
    cloud-sync-* HTML, all GitHub API calls. Replaced with lean autoBackup (IndexedDB).
    
    https://claude.ai/code/session_0185UomEWMArYy7dNV2Bnohp

diff --git a/docs/app.js b/docs/app.js
index e8dce60..f6deaa4 100644
--- a/docs/app.js
+++ b/docs/app.js
@@ -784,7 +784,7 @@ function toggleLike(track) {
   localStorage.setItem('raagam_liked', JSON.stringify(state.liked));
   updateLikeButtons();
   updateLibraryCounts();
-  profileSync.scheduleSave(); // persist liked songs to cloud
+  autoBackup.schedule(); // auto-backup liked songs to IndexedDB
 }
 
 function addToRecent(track) {
@@ -7077,7 +7077,7 @@ function openSettings() {
   if (settingsLang) settingsLang.value = CONFIG.preferredLanguage || 'hindi';
   updateHealthStatusUI();
   updateSleepTimerUI();
-  _refreshCloudSyncUI(); // reflect current sync connection state
+  // (cloud sync UI removed â€” profile backup is automatic)
   // Update EQ and Speed labels in settings
   const settingsEq = $('#settings-eq');
   if (settingsEq) settingsEq.textContent = state.eqPreset === 'off' ? 'Off' : state.eqPreset.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
@@ -7740,6 +7740,14 @@ function showProfileDialog() {
 
     analytics.trackEvent('profile_created', { hasPhone: !!phone, language: lang });
 
+    // Immediately back up the new profile to IndexedDB â€” no user action needed
+    autoBackup.schedule();
+
+    // Request persistent storage so iOS doesn't purge this data after 7 days
+    navigator.storage?.persist?.().then(granted => {
+      if (granted) console.log('[Storage] Persistent storage granted');
+    });
+
     dialog.classList.add('hidden');
     init(); // Continue to next step
   });
@@ -8110,113 +8118,64 @@ function populateUserProfileDialog() {
 
 function saveUserProfile() {
   localStorage.setItem('raagam_user_profile', JSON.stringify(state.userProfile));
-  profileSync.scheduleSave();
-}
-
-// ===== Cloud Profile Sync â€” GitHub Gist =====
-// Stores liked songs, history, playlists & preferences in a private GitHub Gist.
-// Zero backend â€” works entirely on GitHub's free API with a personal access token.
-const profileSync = {
-  gistId:       localStorage.getItem('raagam_gist_id')    || null,
-  token:        localStorage.getItem('raagam_gist_token') || null,
-  _saveTimeout: null,
-  _syncing:     false,
-
-  get configured() { return !!(this.gistId && this.token); },
-
-  // On startup: load remote profile and merge it with local state
-  async init() {
-    if (!this.configured || this._syncing) return;
-    this._syncing = true;
-    try {
-      const remote = await this._fetchGist();
-      if (remote) {
-        this._mergeRemote(remote);
-        console.log('[Cloud Sync] Profile merged from Gist');
-      }
-    } catch(e) {
-      console.warn('[Cloud Sync] Load failed:', e.message);
-    } finally {
-      this._syncing = false;
-    }
-  },
-
-  // First-time setup: validates token, creates secret gist, stores gist ID locally
-  async connect(token) {
-    if (!token?.trim()) throw new Error('Token cannot be empty');
-    token = token.trim();
-
-    // Verify token by fetching authenticated user
-    const me = await fetch('https://api.github.com/user', {
-      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
-    });
-    if (!me.ok) throw new Error(`Invalid token â€” please create one with "gist" scope`);
-    const user = await me.json();
-
-    // Create the gist with current profile snapshot
-    const res = await fetch('https://api.github.com/gists', {
-      method: 'POST',
-      headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
-      body: JSON.stringify({
-        description: `Raagam Music Player â€” profile sync for @${user.login}`,
-        public: false,
-        files: { 'raagam-profile.json': { content: JSON.stringify(this._buildPayload(), null, 2) } }
-      })
+  autoBackup.schedule();
+}
+
+// ===== Auto Profile Backup â€” IndexedDB =====
+// Silently backs up the full profile to IndexedDB on every change.
+// IndexedDB survives iOS 7-day storage purges and browser "Clear History".
+// On startup, if localStorage appears empty, autoBackup restores everything.
+// Zero user action â€” profile is backed up the moment they enter their name.
+const autoBackup = {
+  _db: null,
+  _saveTimer: null,
+  DB_NAME: 'raagam-idb',
+  DB_VER: 1,
+
+  // Open (or reuse) the IndexedDB connection
+  async _open() {
+    if (this._db) return this._db;
+    return new Promise((resolve, reject) => {
+      const req = indexedDB.open(this.DB_NAME, this.DB_VER);
+      req.onupgradeneeded = (e) => {
+        const db = e.target.result;
+        if (!db.objectStoreNames.contains('kv')) {
+          db.createObjectStore('kv', { keyPath: 'k' });
+        }
+      };
+      req.onsuccess  = (e) => { this._db = e.target.result; resolve(this._db); };
+      req.onerror    = ()  => reject(req.error);
     });
-    if (!res.ok) throw new Error(`Could not create Gist (HTTP ${res.status})`);
-    const gist = await res.json();
-
-    this.token  = token;
-    this.gistId = gist.id;
-    localStorage.setItem('raagam_gist_token', token);
-    localStorage.setItem('raagam_gist_id',    gist.id);
-    return { login: user.login, gistUrl: gist.html_url };
-  },
-
-  // Remove credentials â€” data stays in the gist on GitHub but won't auto-save
-  disconnect() {
-    this.token  = null;
-    this.gistId = null;
-    localStorage.removeItem('raagam_gist_token');
-    localStorage.removeItem('raagam_gist_id');
   },
 
-  // Debounced save â€” batches rapid changes (e.g. quick like/unlike) into one PATCH call
-  scheduleSave() {
-    if (!this.configured) return;
-    clearTimeout(this._saveTimeout);
-    this._saveTimeout = setTimeout(() => this.save(), 4000);
+  async _put(key, value) {
+    try {
+      const db = await this._open();
+      const tx = db.transaction('kv', 'readwrite');
+      tx.objectStore('kv').put({ k: key, v: value, t: Date.now() });
+    } catch {}
   },
 
-  async save() {
-    if (!this.configured) return;
+  async _get(key) {
     try {
-      await fetch(`https://api.github.com/gists/${this.gistId}`, {
-        method: 'PATCH',
-        headers: { 'Authorization': `token ${this.token}`, 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          files: { 'raagam-profile.json': { content: JSON.stringify(this._buildPayload(), null, 2) } }
-        })
+      const db = await this._open();
+      return new Promise(resolve => {
+        const tx = db.transaction('kv', 'readonly');
+        const req = tx.objectStore('kv').get(key);
+        req.onsuccess = () => resolve(req.result?.v ?? null);
+        req.onerror   = () => resolve(null);
       });
-    } catch(e) {
-      console.warn('[Cloud Sync] Save failed:', e.message);
-    }
+    } catch { return null; }
   },
 
-  async _fetchGist() {
-    const res = await fetch(`https://api.github.com/gists/${this.gistId}`, {
-      headers: { 'Authorization': `token ${this.token}` }
-    });
-    if (!res.ok) return null;
-    const gist = await res.json();
-    const content = gist.files?.['raagam-profile.json']?.content;
-    return content ? JSON.parse(content) : null;
+  // Debounced save â€” called after any profile change
+  schedule() {
+    clearTimeout(this._saveTimer);
+    this._saveTimer = setTimeout(() => this._saveAll(), 2500);
   },
 
-  _buildPayload() {
-    return {
-      version:        2,
-      savedAt:        new Date().toISOString(),
+  async _saveAll() {
+    await this._put('snapshot', {
       profile:        state.userProfile,
       language:       CONFIG.preferredLanguage,
       liked:          state.liked,
@@ -8225,164 +8184,183 @@ const profileSync = {
       favoriteGenres: state.favoriteGenres,
       skipSignals:    state.skipSignals,
       theme:          state.currentTheme,
-    };
+      savedAt:        Date.now(),
+    });
   },
 
-  // Merge remote data into local state â€” union strategy, local takes precedence for conflicts
-  _mergeRemote(remote) {
-    if (!remote) return;
-
-    // Liked songs â€” union, deduped by track ID
-    if (remote.liked?.length) {
-      const localIds = new Set(state.liked.map(t => t.id));
-      remote.liked.forEach(t => { if (!localIds.has(t.id)) { state.liked.push(t); localIds.add(t.id); } });
-      localStorage.setItem('raagam_liked', JSON.stringify(state.liked));
-    }
-
-    // Playlists â€” take remote if local has none
-    if (remote.playlists?.length && !state.playlists.length) {
-      state.playlists = remote.playlists;
-      localStorage.setItem('raagam_playlists', JSON.stringify(state.playlists));
+  // Called on startup â€” restores from IndexedDB if localStorage was purged
+  async restore() {
+    const snap = await this._get('snapshot');
+    if (!snap) return false;
+
+    let restored = false;
+
+    if (snap.liked?.length && !state.liked.length) {
+      state.liked = snap.liked;
+      localStorage.setItem('raagam_liked', JSON.stringify(snap.liked));
+      restored = true;
+    }
+    if (snap.recent?.length && !state.recent.length) {
+      state.recent = snap.recent;
+      localStorage.setItem('raagam_recent', JSON.stringify(snap.recent));
+      restored = true;
+    }
+    if (snap.playlists?.length && !state.playlists.length) {
+      state.playlists = snap.playlists;
+      localStorage.setItem('raagam_playlists', JSON.stringify(snap.playlists));
+      restored = true;
+    }
+    if (snap.profile && !localStorage.getItem('raagam_profile')) {
+      state.userProfile = snap.profile;
+      CONFIG.userProfile = snap.profile;
+      localStorage.setItem('raagam_profile', JSON.stringify(snap.profile));
+      restored = true;
+    }
+    if (snap.language && !CONFIG.preferredLanguage) {
+      CONFIG.preferredLanguage = snap.language;
+      localStorage.setItem('raagam_language', snap.language);
+      state.languageSetupComplete = true;
+      localStorage.setItem('raagam_language_setup', 'true');
+      restored = true;
     }
 
-    // Play history â€” union, dedup, keep most recent 50
-    if (remote.recent?.length) {
-      const seen = new Set(state.recent.map(t => t.id));
-      remote.recent.forEach(t => { if (!seen.has(t.id)) { state.recent.push(t); seen.add(t.id); } });
-      state.recent = state.recent.slice(0, 50);
-      localStorage.setItem('raagam_recent', JSON.stringify(state.recent));
+    if (restored) {
+      state.homeLoaded = false;
+      try { updateLikeButtons(); }    catch(_) {}
+      try { updateLibraryCounts(); }  catch(_) {}
+      console.log('[AutoBackup] Restored profile from IndexedDB');
     }
+    return restored;
+  },
 
-    // Language â€” apply remote only when local has none set
-    if (remote.language && !CONFIG.preferredLanguage) {
-      CONFIG.preferredLanguage = remote.language;
-      localStorage.setItem('raagam_language', remote.language);
-      state.languageSetupComplete = true;
-      localStorage.setItem('raagam_language_setup', 'true');
-    }
+  // Export profile as a downloadable JSON file
+  exportJSON() {
+    const data = {
+      version:   1,
+      exportedAt: new Date().toISOString(),
+      profile:   state.userProfile,
+      language:  CONFIG.preferredLanguage,
+      liked:     state.liked,
+      playlists: state.playlists,
+      recent:    state.recent.slice(0, 50),
+      theme:     state.currentTheme,
+    };
+    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
+    const url  = URL.createObjectURL(blob);
+    const a    = document.createElement('a');
+    a.href     = url;
+    a.download = `raagam-profile-${new Date().toISOString().slice(0,10)}.json`;
+    a.click();
+    URL.revokeObjectURL(url);
+  },
 
-    // Invalidate home cache so it re-renders with the merged liked/history data
-    state.homeLoaded = false;
-    try { updateLikeButtons(); } catch(_) {}
-    try { updateLibraryCounts(); } catch(_) {}
-  }
+  // Import profile from a JSON file the user selects
+  importJSON(file) {
+    return new Promise((resolve, reject) => {
+      const reader = new FileReader();
+      reader.onload = (e) => {
+        try {
+          const data = JSON.parse(e.target.result);
+          if (data.liked?.length) {
+            const seen = new Set(state.liked.map(t => t.id));
+            data.liked.forEach(t => { if (!seen.has(t.id)) { state.liked.push(t); seen.add(t.id); } });
+            localStorage.setItem('raagam_liked', JSON.stringify(state.liked));
+          }
+          if (data.playlists?.length && !state.playlists.length) {
+            state.playlists = data.playlists;
+            localStorage.setItem('raagam_playlists', JSON.stringify(state.playlists));
+          }
+          if (data.recent?.length) {
+            const seen = new Set(state.recent.map(t => t.id));
+            data.recent.forEach(t => { if (!seen.has(t.id)) { state.recent.push(t); seen.add(t.id); } });
+            state.recent = state.recent.slice(0, 50);
+            localStorage.setItem('raagam_recent', JSON.stringify(state.recent));
+          }
+          if (data.language && !CONFIG.preferredLanguage) {
+            CONFIG.preferredLanguage = data.language;
+            localStorage.setItem('raagam_language', data.language);
+          }
+          state.homeLoaded = false;
+          autoBackup.schedule();
+          resolve(data);
+        } catch(err) { reject(err); }
+      };
+      reader.onerror = () => reject(reader.error);
+      reader.readAsText(file);
+    });
+  },
 };
 
-// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-// Cloud Sync Settings UI â€” injected once into the settings panel
-// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-function _initCloudSyncUI() {
+// â”€â”€ Profile Backup Settings UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Injected into the settings panel once; shows auto-backup status + export/import
+function _initProfileBackupUI() {
   const panel = $('#settings-panel');
-  if (!panel || document.getElementById('cloud-sync-section')) return;
+  if (!panel || document.getElementById('profile-backup-section')) return;
 
   const section = document.createElement('div');
-  section.id = 'cloud-sync-section';
+  section.id = 'profile-backup-section';
   section.className = 'setting-item';
   section.style.cssText = 'flex-direction:column;align-items:stretch;gap:10px;';
   section.innerHTML = `
     <div style="display:flex;justify-content:space-between;align-items:center;">
       <span style="display:flex;align-items:center;gap:6px;font-weight:600;">
-        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"/></svg>
-        Cloud Sync
+        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
+          <path d="M20 6h-2.18c.07-.44.18-.88.18-1.25C18 2.57 15.86 1 13.5 1c-1.4 0-2.72.58-3.65 1.6L9 3.5l-.85-.9C7.22 1.58 5.9 1 4.5 1 2.14 1 0 2.57 0 4.75c0 2.7 2.83 5.05 7.13 8.5L9 14.8l1.87-1.55C15.17 9.8 18 7.45 18 4.75c0-.37-.11-.81-.18-1.25H20c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2v-5h2v5h16V7.5z"/>
+        </svg>
+        Profile &amp; Backup
       </span>
-      <span id="cloud-sync-badge" style="font-size:11px;color:#1DB954;font-weight:600;display:none;">Connected</span>
-    </div>
-
-    <!-- Disconnected state -->
-    <div id="cloud-sync-off">
-      <p style="font-size:12px;color:#b3b3b3;margin:0 0 8px;">
-        Sync liked songs, playlists &amp; history across all your devices using a free <b>private GitHub Gist</b>.
-      </p>
-      <div style="display:flex;gap:8px;">
-        <input id="cloud-sync-token-input" type="password"
-          placeholder="GitHub token (gist scope)"
-          style="flex:1;background:var(--bg-card);border:1px solid var(--border);color:var(--text-primary);
-                 padding:8px 10px;border-radius:8px;font-size:12px;outline:none;" />
-        <button id="cloud-sync-connect-btn"
-          style="background:#1DB954;color:#000;border:none;padding:8px 14px;border-radius:8px;
-                 font-size:12px;font-weight:700;cursor:pointer;white-space:nowrap;">
-          Connect
-        </button>
-      </div>
-      <p style="font-size:10px;color:#666;margin:6px 0 0;">
-        Needs a token with <b>gist</b> scope only.
-        <a href="https://github.com/settings/tokens/new?scopes=gist&description=Raagam+Music+Sync"
-           target="_blank" rel="noopener" style="color:#1DB954;">Create one &rarr;</a>
-      </p>
+      <span style="font-size:11px;color:#1DB954;font-weight:600;">Auto-saved</span>
     </div>
-
-    <!-- Connected state -->
-    <div id="cloud-sync-on" style="display:none;">
-      <p style="font-size:12px;color:#b3b3b3;margin:0 0 8px;">
-        Your liked songs, playlists &amp; history auto-save to a private Gist and load on every device you sign into.
-      </p>
-      <div style="display:flex;gap:8px;">
-        <button id="cloud-sync-save-now-btn"
-          style="flex:1;background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border);
-                 padding:8px;border-radius:8px;font-size:12px;cursor:pointer;">
-          Save Now
-        </button>
-        <button id="cloud-sync-disconnect-btn"
-          style="background:#dc2626;color:#fff;border:none;padding:8px 14px;border-radius:8px;
-                 font-size:12px;font-weight:700;cursor:pointer;">
-          Disconnect
-        </button>
-      </div>
+    <p style="font-size:12px;color:#b3b3b3;margin:0;">
+      Your liked songs, playlists &amp; history are <b>automatically backed up</b> on this device.
+      Export a file to restore your profile on another device.
+    </p>
+    <div style="display:flex;gap:8px;flex-wrap:wrap;">
+      <button id="profile-export-btn"
+        style="flex:1;min-width:120px;background:var(--accent);color:#000;border:none;
+               padding:9px 12px;border-radius:8px;font-size:13px;font-weight:700;cursor:pointer;">
+        Export Profile
+      </button>
+      <label id="profile-import-label"
+        style="flex:1;min-width:120px;background:var(--bg-card);color:var(--text-primary);
+               border:1px solid var(--border);padding:9px 12px;border-radius:8px;
+               font-size:13px;font-weight:600;cursor:pointer;text-align:center;">
+        Import Profile
+        <input id="profile-import-input" type="file" accept=".json" style="display:none;" />
+      </label>
     </div>
+    <div id="profile-backup-info" style="font-size:11px;color:#666;"></div>
   `;
-
-  // Insert near end of settings panel (before last setting-item which is the about/version text)
   panel.appendChild(section);
 
-  // Wire up Connect
-  document.getElementById('cloud-sync-connect-btn').addEventListener('click', async () => {
-    const btn   = document.getElementById('cloud-sync-connect-btn');
-    const input = document.getElementById('cloud-sync-token-input');
-    const token = input.value.trim();
-    if (!token) { showToast('Paste your GitHub token first'); return; }
-    btn.textContent = 'Connectingâ€¦';
-    btn.disabled = true;
-    try {
-      const { login } = await profileSync.connect(token);
-      input.value = '';
-      _refreshCloudSyncUI();
-      showToast(`Cloud Sync connected as @${login}`);
-    } catch(e) {
-      btn.textContent = 'Connect';
-      btn.disabled = false;
-      showToast(e.message);
-    }
+  // Export
+  document.getElementById('profile-export-btn').addEventListener('click', () => {
+    autoBackup.exportJSON();
+    showToast('Profile exported!');
   });
 
-  // Wire up Save Now
-  document.getElementById('cloud-sync-save-now-btn').addEventListener('click', async () => {
-    const btn = document.getElementById('cloud-sync-save-now-btn');
-    btn.textContent = 'Savingâ€¦';
-    btn.disabled = true;
-    await profileSync.save();
-    btn.textContent = 'Saved!';
-    setTimeout(() => { btn.textContent = 'Save Now'; btn.disabled = false; }, 2000);
+  // Import
+  document.getElementById('profile-import-input').addEventListener('change', async (e) => {
+    const file = e.target.files?.[0];
+    if (!file) return;
+    try {
+      await autoBackup.importJSON(file);
+      showToast('Profile imported! Home is refreshingâ€¦');
+      state.homeLoaded = false;
+      loadHome();
+    } catch(err) {
+      showToast('Import failed â€” invalid file');
+    }
+    e.target.value = ''; // reset so same file can be re-selected
   });
 
-  // Wire up Disconnect
-  document.getElementById('cloud-sync-disconnect-btn').addEventListener('click', () => {
-    profileSync.disconnect();
-    _refreshCloudSyncUI();
-    showToast('Cloud Sync disconnected');
+  // Show last backup timestamp
+  autoBackup._get('snapshot').then(snap => {
+    const el = document.getElementById('profile-backup-info');
+    if (!el || !snap?.savedAt) return;
+    const d = new Date(snap.savedAt);
+    el.textContent = `Last backup: ${d.toLocaleDateString()} ${d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
   });
-
-  _refreshCloudSyncUI();
-}
-
-function _refreshCloudSyncUI() {
-  const badge = document.getElementById('cloud-sync-badge');
-  const onEl  = document.getElementById('cloud-sync-on');
-  const offEl = document.getElementById('cloud-sync-off');
-  if (!badge) return;
-  const connected = profileSync.configured;
-  badge.style.display = connected ? 'inline' : 'none';
-  onEl.style.display  = connected ? 'block'  : 'none';
-  offEl.style.display = connected ? 'none'   : 'block';
 }
 
 // Podcast functionality
@@ -9384,13 +9362,15 @@ document.addEventListener('DOMContentLoaded', () => {
   // Initialize podcasts
   initPodcasts();
 
-  // Initialize user profiles
+  // Initialize user profiles and backup UI
   initUserProfiles();
-  _initCloudSyncUI();
+  _initProfileBackupUI();
 
-  // Load remote profile (liked songs, history, playlists) from GitHub Gist if configured.
-  // Runs async â€” home renders with local data immediately; merged cloud data refreshes it.
-  profileSync.init().catch(() => {});
+  // Restore from IndexedDB if localStorage was purged (iOS 7-day purge, cache clear, etc.)
+  // Runs async before init() â€” profile data is available when home renders.
+  autoBackup.restore().then(restored => {
+    if (restored) showToast('Profile restored from backup');
+  }).catch(() => {});
 
   init();
 

commit 660fd5cb2f753d5e2f6d0000c5bc11f339c4d818
Author: Claude <noreply@anthropic.com>
Date:   Thu Feb 19 02:02:28 2026 +0000

    Fix second-open black screen and add GitHub Gist cloud profile sync
    
    Second-open black screen (bfcache fix):
    - Mobile browsers (iOS Safari, Android Chrome) restore tabs from a DOM snapshot
      (bfcache) without re-running JS â€” DOMContentLoaded never fires again, so the
      splash screen is never removed and the app stays black/frozen
    - Added window.addEventListener('pageshow', ...) which fires on EVERY presentation
      including bfcache restores (event.persisted === true); on restore: removes stale
      splash, shows app, resets homeLoaded so home re-renders with fresh profile data
    
    GitHub Gist cloud profile sync:
    - New profileSync object syncs liked songs, playlists, play history, language,
      skip signals and theme to a private GitHub Gist (zero backend, free API)
    - profileSync.connect(token): validates GitHub PAT, creates secret gist, saves ID
    - profileSync.scheduleSave(): debounced 4s â€” batches rapid like/unlike into 1 PATCH
    - profileSync.init(): on startup, fetches gist and merges remote data (union strategy
      â€” deduped by track ID; local always wins on conflicts) then refreshes home
    - Auto-saves triggered from: toggleLike, saveUserProfile (playSong stats)
    - profileSync.init() called in DOMContentLoaded before init() so merged profile
      data (liked songs, history) is available when home sections first render
    
    Cloud Sync Settings UI:
    - _initCloudSyncUI() injects a "Cloud Sync" section into the settings panel
    - Disconnected state: token input field + Connect button + link to create token
    - Connected state: "Save Now" + "Disconnect" buttons + "Connected" badge
    - _refreshCloudSyncUI() called on openSettings() to always show current state
    
    https://claude.ai/code/session_0185UomEWMArYy7dNV2Bnohp

diff --git a/docs/app.js b/docs/app.js
index 3a627d5..e8dce60 100644
--- a/docs/app.js
+++ b/docs/app.js
@@ -784,6 +784,7 @@ function toggleLike(track) {
   localStorage.setItem('raagam_liked', JSON.stringify(state.liked));
   updateLikeButtons();
   updateLibraryCounts();
+  profileSync.scheduleSave(); // persist liked songs to cloud
 }
 
 function addToRecent(track) {
@@ -7076,6 +7077,7 @@ function openSettings() {
   if (settingsLang) settingsLang.value = CONFIG.preferredLanguage || 'hindi';
   updateHealthStatusUI();
   updateSleepTimerUI();
+  _refreshCloudSyncUI(); // reflect current sync connection state
   // Update EQ and Speed labels in settings
   const settingsEq = $('#settings-eq');
   if (settingsEq) settingsEq.textContent = state.eqPreset === 'off' ? 'Off' : state.eqPreset.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
@@ -8108,6 +8110,279 @@ function populateUserProfileDialog() {
 
 function saveUserProfile() {
   localStorage.setItem('raagam_user_profile', JSON.stringify(state.userProfile));
+  profileSync.scheduleSave();
+}
+
+// ===== Cloud Profile Sync â€” GitHub Gist =====
+// Stores liked songs, history, playlists & preferences in a private GitHub Gist.
+// Zero backend â€” works entirely on GitHub's free API with a personal access token.
+const profileSync = {
+  gistId:       localStorage.getItem('raagam_gist_id')    || null,
+  token:        localStorage.getItem('raagam_gist_token') || null,
+  _saveTimeout: null,
+  _syncing:     false,
+
+  get configured() { return !!(this.gistId && this.token); },
+
+  // On startup: load remote profile and merge it with local state
+  async init() {
+    if (!this.configured || this._syncing) return;
+    this._syncing = true;
+    try {
+      const remote = await this._fetchGist();
+      if (remote) {
+        this._mergeRemote(remote);
+        console.log('[Cloud Sync] Profile merged from Gist');
+      }
+    } catch(e) {
+      console.warn('[Cloud Sync] Load failed:', e.message);
+    } finally {
+      this._syncing = false;
+    }
+  },
+
+  // First-time setup: validates token, creates secret gist, stores gist ID locally
+  async connect(token) {
+    if (!token?.trim()) throw new Error('Token cannot be empty');
+    token = token.trim();
+
+    // Verify token by fetching authenticated user
+    const me = await fetch('https://api.github.com/user', {
+      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
+    });
+    if (!me.ok) throw new Error(`Invalid token â€” please create one with "gist" scope`);
+    const user = await me.json();
+
+    // Create the gist with current profile snapshot
+    const res = await fetch('https://api.github.com/gists', {
+      method: 'POST',
+      headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
+      body: JSON.stringify({
+        description: `Raagam Music Player â€” profile sync for @${user.login}`,
+        public: false,
+        files: { 'raagam-profile.json': { content: JSON.stringify(this._buildPayload(), null, 2) } }
+      })
+    });
+    if (!res.ok) throw new Error(`Could not create Gist (HTTP ${res.status})`);
+    const gist = await res.json();
+
+    this.token  = token;
+    this.gistId = gist.id;
+    localStorage.setItem('raagam_gist_token', token);
+    localStorage.setItem('raagam_gist_id',    gist.id);
+    return { login: user.login, gistUrl: gist.html_url };
+  },
+
+  // Remove credentials â€” data stays in the gist on GitHub but won't auto-save
+  disconnect() {
+    this.token  = null;
+    this.gistId = null;
+    localStorage.removeItem('raagam_gist_token');
+    localStorage.removeItem('raagam_gist_id');
+  },
+
+  // Debounced save â€” batches rapid changes (e.g. quick like/unlike) into one PATCH call
+  scheduleSave() {
+    if (!this.configured) return;
+    clearTimeout(this._saveTimeout);
+    this._saveTimeout = setTimeout(() => this.save(), 4000);
+  },
+
+  async save() {
+    if (!this.configured) return;
+    try {
+      await fetch(`https://api.github.com/gists/${this.gistId}`, {
+        method: 'PATCH',
+        headers: { 'Authorization': `token ${this.token}`, 'Content-Type': 'application/json' },
+        body: JSON.stringify({
+          files: { 'raagam-profile.json': { content: JSON.stringify(this._buildPayload(), null, 2) } }
+        })
+      });
+    } catch(e) {
+      console.warn('[Cloud Sync] Save failed:', e.message);
+    }
+  },
+
+  async _fetchGist() {
+    const res = await fetch(`https://api.github.com/gists/${this.gistId}`, {
+      headers: { 'Authorization': `token ${this.token}` }
+    });
+    if (!res.ok) return null;
+    const gist = await res.json();
+    const content = gist.files?.['raagam-profile.json']?.content;
+    return content ? JSON.parse(content) : null;
+  },
+
+  _buildPayload() {
+    return {
+      version:        2,
+      savedAt:        new Date().toISOString(),
+      profile:        state.userProfile,
+      language:       CONFIG.preferredLanguage,
+      liked:          state.liked,
+      playlists:      state.playlists,
+      recent:         state.recent.slice(0, 50),
+      favoriteGenres: state.favoriteGenres,
+      skipSignals:    state.skipSignals,
+      theme:          state.currentTheme,
+    };
+  },
+
+  // Merge remote data into local state â€” union strategy, local takes precedence for conflicts
+  _mergeRemote(remote) {
+    if (!remote) return;
+
+    // Liked songs â€” union, deduped by track ID
+    if (remote.liked?.length) {
+      const localIds = new Set(state.liked.map(t => t.id));
+      remote.liked.forEach(t => { if (!localIds.has(t.id)) { state.liked.push(t); localIds.add(t.id); } });
+      localStorage.setItem('raagam_liked', JSON.stringify(state.liked));
+    }
+
+    // Playlists â€” take remote if local has none
+    if (remote.playlists?.length && !state.playlists.length) {
+      state.playlists = remote.playlists;
+      localStorage.setItem('raagam_playlists', JSON.stringify(state.playlists));
+    }
+
+    // Play history â€” union, dedup, keep most recent 50
+    if (remote.recent?.length) {
+      const seen = new Set(state.recent.map(t => t.id));
+      remote.recent.forEach(t => { if (!seen.has(t.id)) { state.recent.push(t); seen.add(t.id); } });
+      state.recent = state.recent.slice(0, 50);
+      localStorage.setItem('raagam_recent', JSON.stringify(state.recent));
+    }
+
+    // Language â€” apply remote only when local has none set
+    if (remote.language && !CONFIG.preferredLanguage) {
+      CONFIG.preferredLanguage = remote.language;
+      localStorage.setItem('raagam_language', remote.language);
+      state.languageSetupComplete = true;
+      localStorage.setItem('raagam_language_setup', 'true');
+    }
+
+    // Invalidate home cache so it re-renders with the merged liked/history data
+    state.homeLoaded = false;
+    try { updateLikeButtons(); } catch(_) {}
+    try { updateLibraryCounts(); } catch(_) {}
+  }
+};
+
+// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Cloud Sync Settings UI â€” injected once into the settings panel
+// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+function _initCloudSyncUI() {
+  const panel = $('#settings-panel');
+  if (!panel || document.getElementById('cloud-sync-section')) return;
+
+  const section = document.createElement('div');
+  section.id = 'cloud-sync-section';
+  section.className = 'setting-item';
+  section.style.cssText = 'flex-direction:column;align-items:stretch;gap:10px;';
+  section.innerHTML = `
+    <div style="display:flex;justify-content:space-between;align-items:center;">
+      <span style="display:flex;align-items:center;gap:6px;font-weight:600;">
+        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"/></svg>
+        Cloud Sync
+      </span>
+      <span id="cloud-sync-badge" style="font-size:11px;color:#1DB954;font-weight:600;display:none;">Connected</span>
+    </div>
+
+    <!-- Disconnected state -->
+    <div id="cloud-sync-off">
+      <p style="font-size:12px;color:#b3b3b3;margin:0 0 8px;">
+        Sync liked songs, playlists &amp; history across all your devices using a free <b>private GitHub Gist</b>.
+      </p>
+      <div style="display:flex;gap:8px;">
+        <input id="cloud-sync-token-input" type="password"
+          placeholder="GitHub token (gist scope)"
+          style="flex:1;background:var(--bg-card);border:1px solid var(--border);color:var(--text-primary);
+                 padding:8px 10px;border-radius:8px;font-size:12px;outline:none;" />
+        <button id="cloud-sync-connect-btn"
+          style="background:#1DB954;color:#000;border:none;padding:8px 14px;border-radius:8px;
+                 font-size:12px;font-weight:700;cursor:pointer;white-space:nowrap;">
+          Connect
+        </button>
+      </div>
+      <p style="font-size:10px;color:#666;margin:6px 0 0;">
+        Needs a token with <b>gist</b> scope only.
+        <a href="https://github.com/settings/tokens/new?scopes=gist&description=Raagam+Music+Sync"
+           target="_blank" rel="noopener" style="color:#1DB954;">Create one &rarr;</a>
+      </p>
+    </div>
+
+    <!-- Connected state -->
+    <div id="cloud-sync-on" style="display:none;">
+      <p style="font-size:12px;color:#b3b3b3;margin:0 0 8px;">
+        Your liked songs, playlists &amp; history auto-save to a private Gist and load on every device you sign into.
+      </p>
+      <div style="display:flex;gap:8px;">
+        <button id="cloud-sync-save-now-btn"
+          style="flex:1;background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border);
+                 padding:8px;border-radius:8px;font-size:12px;cursor:pointer;">
+          Save Now
+        </button>
+        <button id="cloud-sync-disconnect-btn"
+          style="background:#dc2626;color:#fff;border:none;padding:8px 14px;border-radius:8px;
+                 font-size:12px;font-weight:700;cursor:pointer;">
+          Disconnect
+        </button>
+      </div>
+    </div>
+  `;
+
+  // Insert near end of settings panel (before last setting-item which is the about/version text)
+  panel.appendChild(section);
+
+  // Wire up Connect
+  document.getElementById('cloud-sync-connect-btn').addEventListener('click', async () => {
+    const btn   = document.getElementById('cloud-sync-connect-btn');
+    const input = document.getElementById('cloud-sync-token-input');
+    const token = input.value.trim();
+    if (!token) { showToast('Paste your GitHub token first'); return; }
+    btn.textContent = 'Connectingâ€¦';
+    btn.disabled = true;
+    try {
+      const { login } = await profileSync.connect(token);
+      input.value = '';
+      _refreshCloudSyncUI();
+      showToast(`Cloud Sync connected as @${login}`);
+    } catch(e) {
+      btn.textContent = 'Connect';
+      btn.disabled = false;
+      showToast(e.message);
+    }
+  });
+
+  // Wire up Save Now
+  document.getElementById('cloud-sync-save-now-btn').addEventListener('click', async () => {
+    const btn = document.getElementById('cloud-sync-save-now-btn');
+    btn.textContent = 'Savingâ€¦';
+    btn.disabled = true;
+    await profileSync.save();
+    btn.textContent = 'Saved!';
+    setTimeout(() => { btn.textContent = 'Save Now'; btn.disabled = false; }, 2000);
+  });
+
+  // Wire up Disconnect
+  document.getElementById('cloud-sync-disconnect-btn').addEventListener('click', () => {
+    profileSync.disconnect();
+    _refreshCloudSyncUI();
+    showToast('Cloud Sync disconnected');
+  });
+
+  _refreshCloudSyncUI();
+}
+
+function _refreshCloudSyncUI() {
+  const badge = document.getElementById('cloud-sync-badge');
+  const onEl  = document.getElementById('cloud-sync-on');
+  const offEl = document.getElementById('cloud-sync-off');
+  if (!badge) return;
+  const connected = profileSync.configured;
+  badge.style.display = connected ? 'inline' : 'none';
+  onEl.style.display  = connected ? 'block'  : 'none';
+  offEl.style.display = connected ? 'none'   : 'block';
 }
 
 // Podcast functionality
@@ -9111,6 +9386,11 @@ document.addEventListener('DOMContentLoaded', () => {
 
   // Initialize user profiles
   initUserProfiles();
+  _initCloudSyncUI();
+
+  // Load remote profile (liked songs, history, playlists) from GitHub Gist if configured.
+  // Runs async â€” home renders with local data immediately; merged cloud data refreshes it.
+  profileSync.init().catch(() => {});
 
   init();
 
@@ -9159,3 +9439,31 @@ document.addEventListener('DOMContentLoaded', () => {
   setTimeout(() => _uiRecovery(false), 4000);  // second soft attempt
   setTimeout(() => _uiRecovery(true),  8000);  // hard: clears stuck dialogs, forces show
 });
+
+// ===== bfcache fix =====
+// Mobile browsers (iOS Safari, Android Chrome) restore the DOM from a snapshot
+// when the user switches back to the tab or reopens from the homescreen.
+// In that case DOMContentLoaded never fires again, leaving the splash visible.
+// `pageshow` fires on EVERY page presentation, including bfcache restores.
+window.addEventListener('pageshow', (event) => {
+  if (!event.persisted) return; // normal navigation â€” DOMContentLoaded handles this
+  console.log('[bfcache] Page restored from cache â€” re-surfacing app');
+
+  // Remove stale splash that is still in the cached DOM
+  const splash = $('#splash');
+  if (splash) { splash.style.opacity = '0'; setTimeout(() => splash.remove(), 300); }
+
+  // Make app visible in case it was hidden in the snapshot
+  const app = $('#app');
+  if (app) app.classList.remove('hidden');
+
+  // Reset so home sections re-render (picks up any newly synced profile data)
+  state.homeLoaded = false;
+
+  if (appInitialized) {
+    updateGreeting?.();
+    loadHome?.();
+  } else {
+    init?.();
+  }
+});

commit cd378f59c5e807cbf9515575d1888e9eac0b099d
Author: Claude <noreply@anthropic.com>
Date:   Thu Feb 19 01:33:43 2026 +0000

    Optimize docs/app.js: instant loading, valid category validation, party DJ anti-clustering
    
    Fast loading â€” home renders instantly on repeat visits:
    - loadHome: check today's localStorage cache first (raagam_home_{lang}_{date})
      and populate all 4 sections (trending, language, bollywood, chill) with zero
      API calls; skeletons only shown on first visit of the day
    - Background refresh: _refreshHomeSections() runs silently 6s after page loads to
      keep the cache fresh for next session without blocking the UI
    
    Daily Mix â€” only show categories that have real tracks:
    - renderDailyMixes: shows skeleton mix cards immediately while validation runs
    - Each mix is validated in parallel: apiSearch(query, 5) â€” only mixes with â‰¥ 3
      results are rendered; mixes with no API results are silently dropped
    - _renderValidatedMixCards: new helper renders confirmed-valid cards; shows track
      count on each card subtitle ("5+ tracks")
    - Validated mixes cached (raagam_validated_mixes) for the whole day so subsequent
      opens skip the validation API calls entirely
    
    Party DJ â€” anti-clustering, variety rewards, adjacent-artist prevention:
    - calculateSimilarityScore: reduced same-artist bonus (40â†’15), same-album (20â†’10)
      to stop artist lock-in; added -25 per recent artist occurrence (last 5 played),
      -20 extra for immediate back-to-back; +18 variety bonus for fresh artists
    - getRecommendedTracks: added variety pass over 3Ã— pool â€” skips adjacent same-artist
      tracks in the final selection list, then fills gaps without restriction
    - buildSmartDJQueue: same anti-clustering applied to DJ queue top-up; picks are
      also run through adjacent-artist prevention before splicing into queue
    
    https://claude.ai/code/session_0185UomEWMArYy7dNV2Bnohp

diff --git a/docs/app.js b/docs/app.js
index a1b6e7c..3a627d5 100644
--- a/docs/app.js
+++ b/docs/app.js
@@ -890,10 +890,27 @@ function getRecommendedTracks(currentTrack, allTracks, playedTracks = [], maxRec
     score: calculateSimilarityScore(currentTrack, track, currentLanguage, currentGenre)
   }));
 
-  // Sort by score (highest first) and return top recommendations
-  return scoredTracks
-    .sort((a, b) => b.score - a.score)
-    .slice(0, maxRecommendations);
+  // Sort by score descending, then take a wider pool for variety selection
+  const sorted = scoredTracks.sort((a, b) => b.score - a.score);
+  const pool = sorted.slice(0, maxRecommendations * 3);
+
+  // Variety pass: select from pool ensuring no two adjacent tracks share an artist
+  const result = [];
+  const usedIds = new Set();
+  for (const track of pool) {
+    if (result.length >= maxRecommendations) break;
+    if (usedIds.has(track.id)) continue;
+    const prev = result[result.length - 1];
+    if (prev && getArtistName(prev) === getArtistName(track)) continue; // skip back-to-back same artist
+    result.push(track);
+    usedIds.add(track.id);
+  }
+  // Fill remaining slots if strict filtering left gaps
+  for (const track of sorted) {
+    if (result.length >= maxRecommendations) break;
+    if (!usedIds.has(track.id)) { result.push(track); usedIds.add(track.id); }
+  }
+  return result;
 }
 
 function calculateSimilarityScore(track1, track2, currentLanguage, currentGenre) {
@@ -913,16 +930,26 @@ function calculateSimilarityScore(track1, track2, currentLanguage, currentGenre)
     score += 60;
   }
 
-  // Same artist: medium-high weight
+  // Same artist: smaller affinity bonus â€” full +40 caused too much same-artist clustering
   if (getArtistName(track1) === getArtistName(track2)) {
-    score += 40;
+    score += 15;
   }
 
-  // Same album: medium weight (but lower than language/genre)
+  // Same album: small weight
   if (getAlbumName(track1) === getAlbumName(track2)) {
-    score += 20;
+    score += 10;
   }
 
+  // Anti-clustering: penalise artists the listener has heard recently
+  // Keeps the DJ session feeling varied and party-like rather than artist-locked
+  const recentArtists = (state.playedTracks || []).slice(0, 5).map(t => getArtistName(t));
+  const artistOccurrences = recentArtists.filter(a => a === getArtistName(track2)).length;
+  score -= artistOccurrences * 25; // -25 per recent occurrence (compounding)
+  if (recentArtists[0] === getArtistName(track2)) score -= 20; // extra hit for back-to-back
+
+  // Variety bonus: reward an artist the listener hasn't heard in the last 3 tracks
+  if (!recentArtists.slice(0, 3).includes(getArtistName(track2))) score += 18;
+
   // Theme/keyword matching (reduced weight)
   const themeKeywords = [
     'love', 'romantic', 'heart', 'jaan', 'pyar', 'sad', 'happy', 'emotional',
@@ -1196,9 +1223,11 @@ async function buildSmartDJQueue() {
     const pool  = fresh.length >= 5 ? fresh : results.filter(t => !existingIds.has(t.id));
     if (!pool.length) return;
 
-    // Score using similarity + energy matching
+    // Score using similarity + energy matching + anti-clustering
     const curTrack = state.currentTrack;
     const curEnergy = getEnergyLevel(curTrack);
+    const recentArtists = (state.playedTracks || []).slice(0, 5).map(t => getArtistName(t));
+
     const scored = pool.map(t => {
       let s = curTrack
         ? calculateSimilarityScore(curTrack, t, detectLanguage(curTrack), detectGenre(curTrack))
@@ -1206,11 +1235,31 @@ async function buildSmartDJQueue() {
       // Prefer tracks within Â±1 energy level of current
       const energyDiff = Math.abs(getEnergyLevel(t) - curEnergy);
       s += energyDiff === 0 ? 20 : energyDiff === 1 ? 10 : 0;
+      // Party DJ anti-clustering: penalise recently heard artists
+      const artistCount = recentArtists.filter(a => a === getArtistName(t)).length;
+      s -= artistCount * 30;
+      if (!recentArtists.slice(0, 3).includes(getArtistName(t))) s += 20; // variety bonus
       return { ...t, _score: s };
     }).sort((a, b) => b._score - a._score);
 
-    // Take top 6 tracks
-    const picks = scored.slice(0, 6);
+    // Take top candidates, then ensure no two adjacent tracks share an artist
+    const candidates = scored.slice(0, 12);
+    const picks = [];
+    const usedIds = new Set(state.queue.map(t => t.id));
+    for (const t of candidates) {
+      if (picks.length >= 6) break;
+      if (usedIds.has(t.id)) continue;
+      const prev = picks[picks.length - 1];
+      if (prev && getArtistName(prev) === getArtistName(t)) continue;
+      picks.push(t);
+      usedIds.add(t.id);
+    }
+    // Fill any remaining slots without the adjacency restriction
+    for (const t of scored) {
+      if (picks.length >= 6) break;
+      if (!usedIds.has(t.id)) { picks.push(t); usedIds.add(t.id); }
+    }
+
     state.queue.splice(state.queueIndex + 1, 0, ...picks);
     renderQueue();
 
@@ -1331,36 +1380,93 @@ async function generateDailyMixes() {
 async function renderDailyMixes() {
   const container = $('#daily-mixes-row');
   if (!container) return;
+
+  // Show skeleton cards instantly while we validate each mix has real tracks
+  container.innerHTML = [0,1,2,3,4].map(() => `
+    <div style="flex-shrink:0;width:140px">
+      <div class="skeleton skeleton-card" style="height:140px;border-radius:12px"></div>
+      <div class="skeleton skeleton-text" style="width:80%;margin-top:8px"></div>
+      <div class="skeleton skeleton-text-sm" style="width:60%;margin-top:4px"></div>
+    </div>`).join('');
+
   try {
+    const today = new Date().toDateString();
+    const cacheKey = 'raagam_validated_mixes';
+    const cached = safeParse(cacheKey, null);
+
+    // Reuse today's validated mixes if available â€” zero API calls
+    if (cached?.date === today && cached?.mixes?.length) {
+      _renderValidatedMixCards(container, cached.mixes);
+      return;
+    }
+
     const mixes = await generateDailyMixes();
-    container.innerHTML = mixes.map(mix => `
-      <div class="mix-card" data-query="${mix.query}" data-title="${mix.title}">
-        <div class="mix-card-art" style="background:${mix.gradient}">
-          <span class="mix-card-icon">${mix.icon}</span>
-          <button class="mix-play-btn" aria-label="Play ${mix.title}">â–¶</button>
-        </div>
-        <p class="mix-card-title">${mix.title}</p>
-        <p class="mix-card-sub">${mix.subtitle}</p>
-      </div>`).join('');
-    container.querySelectorAll('.mix-card').forEach(card => {
-      const playHandler = async () => {
-        const query = card.dataset.query;
-        const title = card.dataset.title;
-        showToast(`Loading ${title}...`);
-        const tracks = await apiSearch(query, 15);
-        if (!tracks.length) { showToast('Could not load mix'); return; }
-        state.queue = tracks; state.queueIndex = 0;
-        playSong(tracks[0], false);
-        analytics.trackFeatureUsage('daily_mix_play', { mix: title });
-      };
-      card.addEventListener('click', playHandler);
-      card.querySelector('.mix-play-btn')?.addEventListener('click', (e) => { e.stopPropagation(); playHandler(); });
-    });
+    const MIN_TRACKS = 3;
+
+    // Validate all mixes in parallel: only keep those that return >= MIN_TRACKS real tracks
+    const validated = await Promise.all(
+      mixes.map(async mix => {
+        try {
+          const tracks = await apiSearch(mix.query, MIN_TRACKS + 2);
+          return tracks.length >= MIN_TRACKS ? { ...mix, tracks } : null;
+        } catch { return null; }
+      })
+    );
+
+    const validMixes = validated.filter(Boolean);
+
+    // Cache validated mixes for the rest of the day
+    try {
+      localStorage.setItem(cacheKey, JSON.stringify({ date: today, mixes: validMixes }));
+    } catch {}
+
+    _renderValidatedMixCards(container, validMixes);
   } catch(e) {
     console.warn('[Daily Mixes]', e);
+    container.innerHTML = '<p style="color:var(--text-dim);font-size:13px;padding:20px;text-align:center">Daily mixes unavailable. Check your connection.</p>';
   }
 }
 
+// Renders mix cards for validated mixes (those that confirmed >= 3 tracks)
+function _renderValidatedMixCards(container, mixes) {
+  if (!mixes.length) {
+    container.innerHTML = '<p style="color:var(--text-dim);font-size:13px;padding:20px;text-align:center">No mixes available right now.</p>';
+    return;
+  }
+
+  container.innerHTML = mixes.map((mix, i) => `
+    <div class="mix-card" data-mix-idx="${i}">
+      <div class="mix-card-art" style="background:${mix.gradient}">
+        <span class="mix-card-icon">${mix.icon}</span>
+        <button class="mix-play-btn" aria-label="Play ${mix.title}">â–¶</button>
+      </div>
+      <p class="mix-card-title">${mix.title}</p>
+      <p class="mix-card-sub">${mix.subtitle} Â· ${mix.tracks?.length || 3}+ tracks</p>
+    </div>`).join('');
+
+  container.querySelectorAll('.mix-card').forEach(card => {
+    const mix = mixes[parseInt(card.dataset.mixIdx, 10)];
+    const playHandler = async () => {
+      showToast(`Loading ${mix.title}...`);
+      // Start with pre-validated tracks; fetch more to fill out the queue
+      let tracks = [...(mix.tracks || [])];
+      if (tracks.length < 10) {
+        try {
+          const more = await apiSearch(mix.query, 15);
+          const existIds = new Set(tracks.map(t => t.id));
+          tracks = [...tracks, ...more.filter(t => !existIds.has(t.id))];
+        } catch {}
+      }
+      if (!tracks.length) { showToast('Could not load mix'); return; }
+      state.queue = tracks; state.queueIndex = 0;
+      playSong(tracks[0], false);
+      analytics.trackFeatureUsage('daily_mix_play', { mix: mix.title });
+    };
+    card.addEventListener('click', playHandler);
+    card.querySelector('.mix-play-btn')?.addEventListener('click', e => { e.stopPropagation(); playHandler(); });
+  });
+}
+
 function detectMood(track) {
   const text = `${getTrackName(track)} ${getAlbumName(track)}`.toLowerCase();
 
@@ -1463,16 +1569,17 @@ async function loadHome() {
 
   updateGreeting();
 
-  // Quick picks from recent
+  // â”€â”€ Instant sections (no API needed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+  // Quick Picks from recent plays â€” rendered immediately
   const quickPicks = $('#quick-picks');
   const recentForPicks = state.recent.slice(0, 6);
   if (recentForPicks.length > 0) {
     quickPicks.innerHTML = recentForPicks.map(t => `
       <div class="quick-card" data-id="${t.id}">
-        <img src="${getImage(t, 'low')}" alt="" />
+        <img src="${getImage(t, 'low')}" alt="" loading="lazy" />
         <span>${getTrackName(t)}</span>
-      </div>
-    `).join('');
+      </div>`).join('');
     quickPicks.querySelectorAll('.quick-card').forEach((card, i) => {
       card.addEventListener('click', () => playSong(recentForPicks[i]));
     });
@@ -1480,61 +1587,91 @@ async function loadHome() {
     quickPicks.innerHTML = '';
   }
 
-  // Recently played section
+  // Recently Played â€” rendered immediately from local state
   const recentRow = $('#recent-row');
   if (state.recent.length > 0) {
     recentRow.innerHTML = '';
-    const recentTracks = state.recent.slice(0, 10); // Show last 10 played
-    recentTracks.forEach(t => recentRow.appendChild(renderSongCard(t)));
+    state.recent.slice(0, 10).forEach(t => recentRow.appendChild(renderSongCard(t)));
   } else {
     recentRow.innerHTML = '<p style="color:var(--text-dim);font-size:13px;padding:20px;text-align:center">Play some songs to see them here</p>';
   }
 
-  // P7: Daily Mixes
+  // Daily Mixes â€” async but shows skeletons immediately, only renders valid categories
   renderDailyMixes();
 
-  // Load sections â€” dynamic based on user's preferred language
+  // â”€â”€ API sections (cached for fast reload) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
   const lang = CONFIG.preferredLanguage || 'hindi';
   const langName = CONFIG.supportedLanguages[lang]?.name || 'Hindi';
   const currentYear = new Date().getFullYear();
 
-  // Update section titles dynamically
   const trendingTitle = $('#trending-title');
   const languageTitle = $('#language-title');
   const bollywoodTitle = $('#bollywood-title');
   if (trendingTitle) trendingTitle.textContent = `Trending ${langName} Now`;
   if (languageTitle) languageTitle.textContent = `Latest ${langName} Hits`;
-  if (bollywoodTitle) {
-    // If user's language IS hindi, show a different second section instead of duplicate
-    if (lang === 'hindi') {
-      bollywoodTitle.textContent = 'Bollywood Party Mix';
-    } else {
-      bollywoodTitle.textContent = 'Bollywood Vibes';
-    }
-  }
+  if (bollywoodTitle) bollywoodTitle.textContent = lang === 'hindi' ? 'Bollywood Party Mix' : 'Bollywood Vibes';
 
   const sections = [
-    { id: 'trending-row', query: `trending ${langName} songs ${currentYear}` },
-    { id: 'language-row', query: `new ${langName} songs ${currentYear} latest` },
+    { id: 'trending-row',  query: `trending ${langName} songs ${currentYear}` },
+    { id: 'language-row',  query: `new ${langName} songs ${currentYear} latest` },
     { id: 'bollywood-row', query: lang === 'hindi' ? `bollywood party songs ${currentYear}` : `bollywood top hits ${currentYear}` },
-    { id: 'chill-row', query: 'chill lofi relax' },
+    { id: 'chill-row',     query: 'chill lofi relax' },
   ];
 
+  // Try today's cache â€” renders instantly with zero API calls
+  const today = new Date().toDateString();
+  const sectionCacheKey = `raagam_home_${lang}_${today}`;
+  const cachedSections = safeParse(sectionCacheKey, null);
+
+  if (cachedSections?.length) {
+    sections.forEach((s, i) => {
+      const container = $(`#${s.id}`);
+      if (!container) return;
+      const cached = cachedSections[i];
+      if (cached?.length) {
+        container.innerHTML = '';
+        cached.forEach(t => container.appendChild(renderSongCard(t)));
+      } else {
+        container.innerHTML = '<p style="color:var(--text-dim);font-size:13px;padding:20px">Could not load. Check your connection.</p>';
+      }
+    });
+    state.homeLoaded = true;
+    // Silently refresh cache in background so next session gets fresh content
+    setTimeout(() => _refreshHomeSections(sections, sectionCacheKey), 6000);
+    return;
+  }
+
+  // First load today: show skeletons â†’ fetch all sections in parallel â†’ cache results
   sections.forEach(s => renderSkeletons($(`#${s.id}`)));
 
   const results = await Promise.all(sections.map(s => apiSearch(s.query, 15)));
+  const toCache = [];
   results.forEach((tracks, i) => {
     const container = $(`#${sections[i].id}`);
+    if (!container) return;
     container.innerHTML = '';
     if (tracks.length === 0) {
       container.innerHTML = '<p style="color:var(--text-dim);font-size:13px;padding:20px">Could not load. Check your connection.</p>';
-      return;
+      toCache.push([]);
+    } else {
+      tracks.forEach(t => container.appendChild(renderSongCard(t)));
+      toCache.push(tracks);
     }
-    tracks.forEach(t => container.appendChild(renderSongCard(t)));
   });
 
+  try { localStorage.setItem(sectionCacheKey, JSON.stringify(toCache)); } catch {}
+
   state.homeLoaded = true;
-  console.log('Home loaded successfully');
+}
+
+// Runs silently in the background to keep the home cache fresh for next session
+async function _refreshHomeSections(sections, cacheKey) {
+  try {
+    const results = await Promise.all(sections.map(s => apiSearch(s.query, 15)));
+    const toCache = results.map(tracks => (tracks.length ? tracks : []));
+    localStorage.setItem(cacheKey, JSON.stringify(toCache));
+  } catch {}
 }
 
 // ===== Search =====

commit 76ec8f5ffe4a645d2b01fb0f40e196b939b9b70b
Author: Claude <noreply@anthropic.com>
Date:   Wed Feb 18 13:37:32 2026 +0000

    Fix black screen on reopen and cannot-play audio errors
    
    ## Black screen on browser reopen (root cause: corrupted localStorage)
    
    All JSON.parse() calls in state/CONFIG initialization ran bare â€” if any
    localStorage key held malformed data (from a partial write, storage quota
    error, or old app version), the thrown SyntaxError crashed the entire
    script before DOMContentLoaded, producing a blank black screen with no
    recovery possible.
    
    Fix: added safeParse(key, fallback) helper (defined before CONFIG):
      â€¢ Wraps JSON.parse in try/catch
      â€¢ Clears the corrupted key with localStorage.removeItem so it self-heals
      â€¢ Returns the fallback value so the app continues loading normally
    Converted all 8 bare JSON.parse(localStorage...) calls in state/CONFIG to
    use safeParse: liked, recent, history, favoriteGenres, listeningHistory,
    alarm, playlists, skipSignals, userProfile.
    
    ## UI recovery: 3-tier timeout instead of single 1500ms check
    
    Old code ran one recovery check at 1500ms and skipped it if any dialog
    was visible â€” so a stuck/non-interactive profile or language dialog would
    leave the user on a black screen forever.
    
    New behavior:
      - 1500ms: soft â€” shows app only if no dialog is blocking
      - 4000ms: soft â€” second attempt for slow devices/networks
      - 8000ms: HARD â€” forcibly hides stuck dialogs, creates a minimal
        default profile if needed, shows the app, and calls the setup
        functions that may have been skipped. Shows a recovery toast.
    
    ## Cannot play song: silent audio failures
    
    1. togglePlay() called audio.play() with no .catch() â€” browser autoplay
       policy (NotAllowedError) and network errors were silently swallowed
       while state.isPlaying was set to true, making the play button appear
       active but producing no sound.
       Fix: added .catch() that shows specific toast per error type and resets
       state.isPlaying so the button returns to the correct state.
    
    2. No audio 'error' event listener existed â€” CORS failures, network drops,
       and unsupported codecs fired an error event that was completely ignored.
       Fix: added audio.addEventListener('error', ...) that:
         â€¢ Shows a human-readable message per MediaError.code (1-4)
         â€¢ Resets isPlaying/UI immediately
         â€¢ Auto-advances to the next track after 1.2s
    
    3. Main audio element had no crossOrigin attribute, unlike the DJ deck
       audio elements which all set crossOrigin='anonymous'. Without this,
       the Web Audio API's AnalyserNode connection throws a SecurityError on
       cross-origin streams, which can block playback entirely on some browsers.
       Fix: audio.crossOrigin = 'anonymous' set in event setup.
    
    https://claude.ai/code/session_018c6cPVkLv5aqxc51PHd15f

diff --git a/docs/app.js b/docs/app.js
index 31758c8..a1b6e7c 100644
--- a/docs/app.js
+++ b/docs/app.js
@@ -5,6 +5,19 @@ const $ = (s) => document.querySelector(s);
 const $$ = (s) => document.querySelectorAll(s);
 const audio = document.querySelector('#audio');
 
+// ===== Safe localStorage helper â€” prevents black screen from corrupted data =====
+function safeParse(key, fallback) {
+  try {
+    const raw = localStorage.getItem(key);
+    if (raw === null) return fallback;
+    return JSON.parse(raw);
+  } catch (e) {
+    console.warn(`[safeParse] Corrupted localStorage key "${key}" â€” cleared.`, e);
+    try { localStorage.removeItem(key); } catch (_) {}
+    return fallback;
+  }
+}
+
 // ===== Config =====
 const CONFIG = {
   apiBase: localStorage.getItem('raagam_api') || 'https://jiosaavn-api-privatecvc2.vercel.app',
@@ -18,7 +31,7 @@ const CONFIG = {
     'https://saavn.dev/api'
   ],
   preferredLanguage: localStorage.getItem('raagam_language') || null,
-  userProfile: JSON.parse(localStorage.getItem('raagam_profile') || 'null'),
+  userProfile: safeParse('raagam_profile', null),
   supportedLanguages: {
     'hindi': { name: 'Hindi', keywords: ['hindi', 'bollywood', 'filmi', 'indian pop'] },
     'telugu': { name: 'Telugu', keywords: ['telugu', 'tollywood', 'telangana'] },
@@ -43,9 +56,9 @@ const state = {
   isPlaying: false,
   shuffle: false,
   repeat: 'off', // off, all, one
-  liked: JSON.parse(localStorage.getItem('raagam_liked') || '[]'),
-  recent: JSON.parse(localStorage.getItem('raagam_recent') || '[]'),
-  history: JSON.parse(localStorage.getItem('raagam_history') || '[]'),  // [{track, playedAt}]
+  liked: safeParse('raagam_liked', []),
+  recent: safeParse('raagam_recent', []),
+  history: safeParse('raagam_history', []),  // [{track, playedAt}]
   currentView: 'home',
   searchCache: {},
   albumCache: {},   // { albumId: albumData }
@@ -55,8 +68,8 @@ const state = {
   playedTracks: [], // tracks played in current session for recommendations
   languageSetupComplete: localStorage.getItem('raagam_language_setup') === 'true',
   userProfile: CONFIG.userProfile,
-  favoriteGenres: JSON.parse(localStorage.getItem('raagam_favorite_genres') || '[]'),
-  listeningHistory: JSON.parse(localStorage.getItem('raagam_listening_history') || '[]'),
+  favoriteGenres: safeParse('raagam_favorite_genres', []),
+  listeningHistory: safeParse('raagam_listening_history', []),
   // New feature states
   sleepTimer: null,         // setTimeout reference
   sleepTimerEnd: null,      // timestamp when sleep fires
@@ -66,7 +79,7 @@ const state = {
   lyricsCache: {},          // { trackId: { lyrics, copyright } }
   lyricsVisible: false,
   // Alarm state
-  alarm: JSON.parse(localStorage.getItem('raagam_alarm') || 'null'),  // { time, songId, songData, autoplay, gentle }
+  alarm: safeParse('raagam_alarm', null),  // { time, songId, songData, autoplay, gentle }
   alarmTimer: null,
   alarmCheckInterval: null,
   alarmSelectedSong: null,  // temp song selection in dialog
@@ -75,7 +88,7 @@ const state = {
   alarmWakeLock: null,
   alarmSWRegistration: null,
   // Custom Playlists
-  playlists: JSON.parse(localStorage.getItem('raagam_playlists') || '[]'), // [{id,name,tracks:[],createdAt}]
+  playlists: safeParse('raagam_playlists', []), // [{id,name,tracks:[],createdAt}]
   // Crossfade
   crossfadeDuration: parseInt(localStorage.getItem('raagam_crossfade') || '0'), // seconds (0=off)
   crossfadeAudio: null, // second Audio element for crossfade
@@ -112,7 +125,7 @@ const state = {
   offlineDownloading: new Set(), // Set of track IDs currently downloading
   // â”€â”€ Priority Feature States â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   // P1: Skip Signal Learning
-  skipSignals: JSON.parse(localStorage.getItem('raagam_skip_signals') || '{}'),
+  skipSignals: safeParse('raagam_skip_signals', {}),
   // P2/P3: Smart DJ + Vibe Arcs
   smartDJEnabled: localStorage.getItem('raagam_smartdj') === 'true',
   smartDJVibe: localStorage.getItem('raagam_smartdj_vibe') || 'auto',
@@ -1939,7 +1952,16 @@ function playSong(track, addToQueue = true) {
 function togglePlay() {
   if (!state.currentTrack) return;
   if (audio.paused) {
-    audio.play();
+    audio.play().catch(e => {
+      if (e.name === 'AbortError') return; // interrupted by new src â€” harmless
+      if (e.name === 'NotAllowedError') {
+        showToast('Tap to play â€” browser needs a gesture first');
+      } else {
+        showToast('Could not resume playback');
+      }
+      state.isPlaying = false;
+      updatePlayerUI();
+    });
     state.isPlaying = true;
     analytics.trackMusicAction('resume');
   } else {
@@ -7012,11 +7034,32 @@ function setupEvents() {
   seek.addEventListener('touchend', () => seek._dragging = false);
   seek.addEventListener('change', () => seek._dragging = false);
 
+  // Allow CORS so Web Audio API can read the stream (same as DJ deck elements)
+  audio.crossOrigin = 'anonymous';
+
   // Audio events
   audio.addEventListener('timeupdate', updateProgress);
   audio.addEventListener('ended', playNext);
   audio.addEventListener('play', () => { state.isPlaying = true; updatePlayerUI(); });
   audio.addEventListener('pause', () => { state.isPlaying = false; updatePlayerUI(); });
+  audio.addEventListener('error', (e) => {
+    const err = audio.error;
+    const MESSAGES = {
+      1: 'Playback aborted',
+      2: 'Network error â€” check your connection',
+      3: 'Track could not be decoded',
+      4: 'Track not supported or unavailable',
+    };
+    const msg = (err && MESSAGES[err.code]) || 'Could not play track';
+    console.warn('[audio error]', err?.code, err?.message);
+    if (state.currentTrack) {
+      showToast(`${msg} â€” trying next`);
+      state.isPlaying = false;
+      updatePlayerUI();
+      // Auto-advance to next track after a short delay
+      setTimeout(() => { if (!state.isPlaying) playNext(); }, 1200);
+    }
+  });
 
   // Queue
   $('#np-queue-btn').addEventListener('click', openQueue);
@@ -8934,26 +8977,48 @@ document.addEventListener('DOMContentLoaded', () => {
 
   init();
 
-  // Recovery: if app remains hidden after initialization and no dialog is visible, force-show the UI
-  setTimeout(() => {
+  // Recovery: if app remains hidden after initialization, force-show at 1.5s / 4s / 8s.
+  // The 8-second hard recovery also dismisses stuck dialogs (profile / language) that
+  // may have failed to attach event listeners, which would otherwise leave a black screen.
+  function _uiRecovery(hard) {
     try {
-      const appEl = $('#app');
-      const splashEl = $('#splash');
-      const profileDlg = $('#profile-dialog');
-      const langDlg = $('#language-dialog');
-      if (appEl && appEl.classList.contains('hidden') &&
-        (!profileDlg || profileDlg.classList.contains('hidden')) &&
-        (!langDlg || langDlg.classList.contains('hidden')) ) {
-        console.warn('UI recovery: forcing app to show because initialization did not complete.');
+      const appEl  = $('#app');
+      const splash = $('#splash');
+      const pdlg   = $('#profile-dialog');
+      const ldlg   = $('#language-dialog');
+      if (!appEl || !appEl.classList.contains('hidden')) return; // already visible
+
+      const dialogsHidden = (!pdlg || pdlg.classList.contains('hidden')) &&
+                            (!ldlg || ldlg.classList.contains('hidden'));
+
+      if (dialogsHidden || hard) {
+        // Hide any stuck dialogs on hard recovery
+        if (hard && !dialogsHidden) {
+          pdlg?.classList.add('hidden');
+          ldlg?.classList.add('hidden');
+          // Create a minimal profile so init() won't loop back
+          if (!state.userProfile) {
+            state.userProfile = CONFIG.userProfile = { name: 'Music Lover', phone: '' };
+            localStorage.setItem('raagam_profile', JSON.stringify(state.userProfile));
+          }
+          if (!state.languageSetupComplete) {
+            state.languageSetupComplete = true;
+            localStorage.setItem('raagam_language_setup', 'true');
+          }
+        }
+        console.warn(`[UI recovery${hard ? ' HARD' : ''}] Forcing app visible`);
         appEl.classList.remove('hidden');
-        if (splashEl) {
-          splashEl.style.opacity = '0';
-          setTimeout(() => splashEl.remove(), 400);
+        if (splash) { splash.style.opacity = '0'; setTimeout(() => splash.remove(), 400); }
+        if (!appInitialized) {
+          try { setupEvents(); setupSearch(); setupLibrary(); loadHome(); } catch (_) {}
         }
-        showToast('Recovered UI â€” if you still see issues clear site storage from Settings.');
+        if (hard) showToast('App recovered â€” if issues persist, go to Settings â†’ Clear Data');
       }
     } catch (e) {
-      console.warn('UI recovery check failed:', e);
+      console.warn('UI recovery failed:', e);
     }
-  }, 1500);
+  }
+  setTimeout(() => _uiRecovery(false), 1500);  // soft: only fires if no dialog visible
+  setTimeout(() => _uiRecovery(false), 4000);  // second soft attempt
+  setTimeout(() => _uiRecovery(true),  8000);  // hard: clears stuck dialogs, forces show
 });
